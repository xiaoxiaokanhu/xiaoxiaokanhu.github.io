<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小看护</title>
  
  <subtitle>守护自己，守护家人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-15T10:45:36.022Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小小看护</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习nginx遇到的一些问题</title>
    <link href="http://yoursite.com/2019/01/15/%E5%AD%A6%E4%B9%A0nginx%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/15/学习nginx遇到的一些问题/</id>
    <published>2019-01-15T10:41:47.000Z</published>
    <updated>2019-01-15T10:45:36.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx-找不到安装地址"><a href="#nginx-找不到安装地址" class="headerlink" title="nginx 找不到安装地址"></a>nginx 找不到安装地址</h3><p>今天看到了nginx,想到我在服务器里面安装了nginx，只是还没有用到，所以想看下其安装地址，却没有找到，后来谷歌下，发现用<code>nginx -t</code>就可以找到nginx.conf的文件位置，从而知道nginx的安装位置。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># nginx -t</span><br><span class="line">nginx: the configuration <span class="keyword">file</span> /etc/nginx/nginx.<span class="keyword">conf</span> <span class="keyword">syntax</span> <span class="keyword">is</span> ok</span><br><span class="line">nginx: configuration <span class="keyword">file</span> /etc/nginx/nginx.<span class="keyword">conf</span> test <span class="keyword">is</span> successful</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;nginx-找不到安装地址&quot;&gt;&lt;a href=&quot;#nginx-找不到安装地址&quot; class=&quot;headerlink&quot; title=&quot;nginx 找不到安装地址&quot;&gt;&lt;/a&gt;nginx 找不到安装地址&lt;/h3&gt;&lt;p&gt;今天看到了nginx,想到我在服务器里面安装了ngi
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Python基础系列之*args和**kwargs的认识</title>
    <link href="http://yoursite.com/2019/01/06/Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B-args%E5%92%8C-kwargs/"/>
    <id>http://yoursite.com/2019/01/06/Python基础系列之-args和-kwargs/</id>
    <published>2019-01-06T14:46:05.000Z</published>
    <updated>2019-01-06T15:02:47.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>*args和**kwargs这两个参数咱们经常用到，今天在巩固基础的时候，看到了这两个参数，做了一下对比，所以记录一下。</p></blockquote><h3 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h3><p>*args这种写法代表的是 <strong>元组</strong>，就比如我上面为啥说它们是参数，是因为他们经常在函数的参数中出现。<br>下面咱们在例子中来说明<br><a id="more"></a><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getTupleParameter(x, *<span class="keyword">args</span>):</span><br><span class="line">    <span class="keyword">print</span>('x is &#123;&#125;'.<span class="keyword">format</span>(x)) </span><br><span class="line">    <span class="keyword">print</span>('<span class="keyword">args</span> is &#123;&#125;'.<span class="keyword">format</span>(<span class="keyword">args</span>))</span><br><span class="line">    <span class="keyword">print</span>('<span class="keyword">type</span> is &#123;&#125;'.<span class="keyword">format</span>(<span class="keyword">type</span>(<span class="keyword">args</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">args</span>:</span><br><span class="line">        <span class="keyword">print</span>('i is &#123;&#125;'.<span class="keyword">format</span>(i))</span><br><span class="line"></span><br><span class="line">getTupleParameter(1, 2, 3, 4, 5, 6, 7)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>('*'*100)</span><br><span class="line">getTupleParameter(1)</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">args <span class="keyword">is</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br><span class="line">i <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">4</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">6</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">7</span></span><br><span class="line">********************************************************************</span><br><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">args <span class="keyword">is</span> ()</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a>**kwargs</h3><p>*kwargs这种写法代表的是 <strong>字典</strong>，下面咱们在例子中来说明<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getDictParameter(x, **kwargs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x is &#123;&#125;'</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'kwargs is &#123;&#125;'</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'type is &#123;&#125;'</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(kwargs)))</span><br><span class="line"></span><br><span class="line">getDictParameter(<span class="number">1</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">getDictParameter(<span class="number">1</span>)</span><br><span class="line">res = dict(</span><br><span class="line">    a=<span class="number">1</span>,</span><br><span class="line">    b=<span class="number">2</span>,</span><br><span class="line">    c=<span class="number">3</span></span><br><span class="line">)</span><br><span class="line">getDictParameter(<span class="number">1</span>, **res)</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="type">is </span>&lt;class <span class="symbol">'dict</span>'&gt;</span><br><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="type">is </span>&lt;class <span class="symbol">'dict</span>'&gt;</span><br><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="type">is </span>&lt;class <span class="symbol">'dict</span>'&gt;</span><br></pre></td></tr></table></figure></p><h3 id="args和-kwargs的混合使用"><a href="#args和-kwargs的混合使用" class="headerlink" title="*args和**kwargs的混合使用"></a>*args和**kwargs的混合使用</h3><p>*args和**kwargs在程序中一起使用很常见<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getTupleAndDict(x, *args, **kwargs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x is &#123;&#125;'</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'kwargs is &#123;&#125;'</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'args is &#123;&#125;'</span>.<span class="built_in">format</span>(args))</span><br><span class="line">getTupleAndDict(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, A=<span class="number">1</span>, B=<span class="number">2</span>, C=<span class="number">3</span>, D=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;<span class="string">'D'</span>: <span class="number">4</span>, <span class="string">'C'</span>: <span class="number">3</span>, <span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">args</span> <span class="keyword">is</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;*args和**kwargs这两个参数咱们经常用到，今天在巩固基础的时候，看到了这两个参数，做了一下对比，所以记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;args&quot;&gt;&lt;a href=&quot;#args&quot; class=&quot;headerlink&quot; title=&quot;*args&quot;&gt;&lt;/a&gt;*args&lt;/h3&gt;&lt;p&gt;*args这种写法代表的是 &lt;strong&gt;元组&lt;/strong&gt;，就比如我上面为啥说它们是参数，是因为他们经常在函数的参数中出现。&lt;br&gt;下面咱们在例子中来说明&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux find命令的使用</title>
    <link href="http://yoursite.com/2018/12/29/Linux-find%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/29/Linux-find命令的使用/</id>
    <published>2018-12-29T07:58:44.000Z</published>
    <updated>2018-12-29T09:03:06.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。<br><a id="more"></a></p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>find 地址 参数 </p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</span><br><span class="line">expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</span><br><span class="line">-mount, -<span class="string">xdev :</span> 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</span><br><span class="line">-amin <span class="string">n :</span> 在过去 n 分钟内被读取过</span><br><span class="line">-anewer <span class="string">file :</span> 比文件 file 更晚被读取过的文件</span><br><span class="line">-atime <span class="string">n :</span> 在过去n天内被读取过的文件</span><br><span class="line">-cmin <span class="string">n :</span> 在过去 n 分钟内被修改过</span><br><span class="line">-cnewer <span class="string">file :</span>比文件 file 更新的文件</span><br><span class="line">-ctime <span class="string">n :</span> 在过去n天内被修改过的文件</span><br><span class="line">-<span class="string">empty :</span> 空的文件-gid n or -group <span class="string">name :</span> gid 是 n 或是 group 名称是 name</span><br><span class="line">-ipath p, -path <span class="string">p :</span> 路径名称符合 p 的文件，ipath 会忽略大小写</span><br><span class="line">-name name, -iname <span class="string">name :</span> 文件名称符合 name 的文件。iname 会忽略大小写</span><br><span class="line">-size <span class="string">n :</span> 文件大小 是 n 单位，b 代表 <span class="number">512</span> 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type <span class="string">c :</span> 文件类型是 c 的文件。</span><br><span class="line"><span class="string">d:</span> 目录</span><br><span class="line"><span class="string">c:</span> 字型装置文件</span><br><span class="line"><span class="string">b:</span> 区块装置文件</span><br><span class="line"><span class="string">p:</span> 具名贮列</span><br><span class="line"><span class="string">f:</span> 一般文件</span><br><span class="line"><span class="string">l:</span> 符号连结</span><br><span class="line"><span class="string">s:</span> socket</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查找当前目录及其子目录下的名字为Podfile的文件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> . -name Podfile</span><br></pre></td></tr></table></figure></p><p>查找etc目录下名字为所有延伸档名是 .c 的文件列出来<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> /etc -<span class="built_in">name</span> <span class="string">'*.c'</span></span><br></pre></td></tr></table></figure></p><p>查找在系统中最后10分钟访问的文件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> / -amin -10</span><br></pre></td></tr></table></figure></p><p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> . -ctime -20</span><br></pre></td></tr></table></figure></p><p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> /<span class="built_in">var</span>/<span class="built_in">log</span> -<span class="built_in">type</span> f -mtime +<span class="number">7</span> -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">find</span> . -<span class="keyword">type</span> f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> f -<span class="built_in">size</span> <span class="number">0</span> -<span class="built_in">exec</span> ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>其他的例子<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">find / -amin -<span class="number">10</span> 　　<span class="comment"># 查找在系统中最后10分钟访问的文件(access time)</span></span><br><span class="line">find / -atime -<span class="number">2</span>　　 <span class="comment"># 查找在系统中最后48小时访问的文件</span></span><br><span class="line">find / -empty 　　<span class="comment"># 查找在系统中为空的文件或者文件夹</span></span><br><span class="line">find / -<span class="keyword">group</span> <span class="title">cat</span> 　　<span class="comment"># 查找在系统中属于 group为cat的文件</span></span><br><span class="line">find / -mmin -<span class="number">5</span> 　　<span class="comment"># 查找在系统中最后5分钟里修改过的文件(modify time)</span></span><br><span class="line">find / -mtime -<span class="number">1</span> 　　<span class="comment">#查找在系统中最后24小时里修改过的文件</span></span><br><span class="line">find / -<span class="keyword">user</span> <span class="title">fred</span> 　　<span class="comment">#查找在系统中属于fred这个用户的文件</span></span><br><span class="line">find / -size +<span class="number">10000</span>c　　<span class="comment">#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)</span></span><br><span class="line">find / -size -<span class="number">1000</span>k 　　<span class="comment">#查找出小于1000KB的文件</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.使用混合查找方式查找文件</span><br><span class="line"></span><br><span class="line">　参数有： ！，-<span class="keyword">and</span>(-a)，-<span class="keyword">or</span>(-o)。</span><br><span class="line">find /tmp -size +<span class="number">10000</span>c -<span class="keyword">and</span> -mtime +<span class="number">2</span> 　　<span class="comment">#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</span></span><br><span class="line">find / -<span class="keyword">user</span> <span class="title">fred</span> -<span class="keyword">or</span> -<span class="keyword">user</span> <span class="title">george</span> 　　<span class="comment">#在/目录下查找用户是fred或者george的文件文件</span></span><br><span class="line">find /tmp ! -<span class="keyword">user</span> <span class="title">panda</span>　　<span class="comment">#在/tmp目录中查找所有不属于panda用户的文件</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>2018的总结</title>
    <link href="http://yoursite.com/2018/12/29/%E6%9D%82%E8%B0%88/"/>
    <id>http://yoursite.com/2018/12/29/杂谈/</id>
    <published>2018-12-29T07:58:18.000Z</published>
    <updated>2018-12-29T08:18:03.351Z</updated>
    
    <content type="html"><![CDATA[<p>2018年很快进入了尾声，想想今年不在想过碌碌无为的事情，开始有了自己的规划。一方面可能是因为有了压力，另一方面感觉自己需要更多的成长。2018年定的任务完成度完成了70%，自己感觉完成的不好。需要更多的激励，更多的鞭策。在最后的2018年的几天了，想着自己2019年的规划，落实到实际过程中，不在庸庸碌碌，用这边文章来写下自己的心路历程。只写自己的成长方面</p><h3 id="拓展书籍"><a href="#拓展书籍" class="headerlink" title="拓展书籍"></a>拓展书籍</h3><p>读至少12本书，也就是一个月一本书</p><ul><li>风闻有你</li><li>耶路撒冷三千年</li><li>加尔文要义</li><li></li></ul><h3 id="专业书籍"><a href="#专业书籍" class="headerlink" title="专业书籍"></a>专业书籍</h3><p>随着工作，发现自己需要学习的越来越多，所以今年至少需要看的书籍。PS:以后再补充</p><ul><li>跟着老齐学python(持之以恒，有始有终)</li><li>数据结构</li><li>python核心编程</li><li>算法</li></ul><h3 id="圣经"><a href="#圣经" class="headerlink" title="圣经"></a>圣经</h3><p>怎么都不能没有自己的信仰，圣经也是需要读一遍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年很快进入了尾声，想想今年不在想过碌碌无为的事情，开始有了自己的规划。一方面可能是因为有了压力，另一方面感觉自己需要更多的成长。2018年定的任务完成度完成了70%，自己感觉完成的不好。需要更多的激励，更多的鞭策。在最后的2018年的几天了，想着自己2019年的规划
      
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Supervisor管理进程</title>
    <link href="http://yoursite.com/2018/12/26/Supervisor%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/26/Supervisor管理进程/</id>
    <published>2018-12-26T07:27:04.000Z</published>
    <updated>2019-01-16T08:32:03.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 Supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，Supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip 安装:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip <span class="keyword">install</span> supervisor</span><br></pre></td></tr></table></figure></p><p>因为supervisor，只能安装在python2.X上面，目前开发用的是3.5.0，所以这里用到了pyenv。pyenv来管理用python2.X还是python3.X。学习pyenv请点链接：<a href="https://blog.gideondudu.com/2018/10/31/Mac%E4%B8%8Bpyenv%E4%B8%8Epyenv-virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">pyenv</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分 Supervisor（Supervisor 是一个 C/S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）</p></blockquote><p>首先来看 Supervisor 的配置文件。安装完 Supervisor 之后，可以运行 echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span>_supervisord_conf &gt; <span class="string">/etc/supervisord.conf</span></span><br></pre></td></tr></table></figure></p><p>去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ; socket 文件的 mode，默认是 0700</span><br><span class="line"><span class="section">;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span></span><br><span class="line">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span><br><span class="line"><span class="section">;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span></span><br><span class="line">;username=user              ; 登录管理后台的用户名</span><br><span class="line">;password=123               ; 登录管理后台的密码</span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB</span><br><span class="line">logfile_backups=10           ; 日志文件保留备份数量默认 10</span><br><span class="line">loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ; pid 文件</span><br><span class="line">nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ; 可以打开的进程数的最小值，默认 200</span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span></span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span><br><span class="line"><span class="section">;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span></span><br><span class="line">; 包含其他的配置文件</span><br><span class="line">[<span class="keyword">include</span>]</span><br><span class="line">files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini</span><br></pre></td></tr></table></figure></p><p>我们把上面这部分配置保存到 /etc/supervisord.conf（或其他任意有权限访问的文件）然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c <span class="regexp">/etc/</span>supervisord.conf</span><br></pre></td></tr></table></figure></p><p>查看 supervisord 是否在运行：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> supervisord</span><br></pre></td></tr></table></figure></p><h2 id="program-配置"><a href="#program-配置" class="headerlink" title="program 配置"></a>program 配置</h2><p>上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。可以把所有配置项都写到 supervisord.conf 文件里，但并不推荐这样做，而是通过 include 的方式把不同的程序（组）写到不同的配置文件里。<br>为了举例，我们新建一个目录 /etc/supervisor/ 用于存放这些配置文件，相应的，把 /etc/supervisord.conf 里 include 部分的的配置修改一下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure></p><p>假设有个用 Python 和 Flask 框架编写的用户中心系统，取名 usercenter，用 gunicorn 做 web 服务器。项目代码位于 /home/leon/projects/usercenter，gunicorn 配置文件为 gunicorn.py，WSGI callable 是 wsgi.py 里的 app 属性。所以直接在命令行启动的，方式可能是这样的：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>leon<span class="regexp">/projects/</span>usercenter</span><br><span class="line">gunicorn -c gunicorn.py <span class="string">wsgi:</span>app</span><br></pre></td></tr></table></figure></p><p>现在编写一份配置文件来管理这个进程（需要注意：用 supervisord 管理时，gunicorn 的 daemon 选项需要设置为 False）：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:usercenter]</span></span><br><span class="line"><span class="attr">directory</span> = /home/leon/projects/usercenter ; 程序的启动目录</span><br><span class="line"><span class="attr">command</span> = gunicorn -c gunicorn.py wsgi:app  ; 启动命令，可以看出与手动在命令行启动的命令是一样的</span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span>     ; 在 supervisord 启动的时候也自动启动</span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span>        ; 启动 <span class="number">5</span> 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span>   ; 程序异常退出后自动重启</span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span>     ; 启动失败自动重试次数，默认是 <span class="number">3</span></span><br><span class="line"><span class="attr">user</span> = leon          ; 用哪个用户启动</span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span>  ; 把 stderr 重定向到 stdout，默认 <span class="literal">false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">20</span>MB  ; stdout 日志文件大小，默认 <span class="number">50</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span>     ; stdout 日志文件备份数</span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /data/logs/usercenter_stdout.log</span><br><span class="line"><span class="comment">; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH</span></span><br><span class="line"><span class="comment">; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere</span></span><br></pre></td></tr></table></figure></p><p>一份配置文件至少需要一个 [program:x] 部分的配置，来告诉 supervisord 需要管理那个进程。[program:x] 语法中的 x 表示 program name，会在客户端（supervisorctl 或 web 界面）显示，在 supervisorctl 中通过这个值来对程序进行 start、restart、stop 等操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Supervisor" scheme="http://yoursite.com/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>python数组的相关知识</title>
    <link href="http://yoursite.com/2018/12/25/python%E6%95%B0%E7%BB%84%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/25/python数组交集、并集、差集/</id>
    <published>2018-12-25T02:43:28.000Z</published>
    <updated>2018-12-25T03:05:26.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数组是在python中很常见，所以关于数组的知识点也相当重要。这篇博客是把工作中用到的知识点记录一下，持续更新中</p></blockquote><a id="more"></a><p>1、<a href="#markdown-jiaoji">数组的交集、并集、差集</a><br>2、<a href="#markdown-zhuanhuan">数组转字符串，字符串转数组</a></p><h2 id="数组的交集、并集、差集"><a href="#数组的交集、并集、差集" class="headerlink" title="数组的交集、并集、差集"></a><a name="markdown-jiaoji"></a>数组的交集、并集、差集</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 3, 65, 2, 7]</span><br><span class="line">b = [3, 2, 5, 4]</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(a).intersection(<span class="builtin-name">set</span>(b))) # 交集</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(a).union(<span class="builtin-name">set</span>(b))) # 并集</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(a).difference(<span class="builtin-name">set</span>(b))) # 差集，在a中但不在b中的元素</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(b).difference(<span class="builtin-name">set</span>(a))) # 差集，在b中但不在a中的元素</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">65</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">65</span>, <span class="number">1</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组转字符串，字符串转数组"><a href="#数组转字符串，字符串转数组" class="headerlink" title="数组转字符串，字符串转数组"></a><a name="markdown-zhuanhuan"></a>数组转字符串，字符串转数组</h2><p><strong>字符串转数组</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">'1,2,3'</span></span><br><span class="line">arr = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">','</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"arr is &#123;&#125;"</span>.format(arr))</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">is</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p><strong>数组转字符串</strong><br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">arr = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">str1 = <span class="string">','</span>.<span class="keyword">join</span>(arr)</span><br><span class="line">print(<span class="string">'str1 is &#123;&#125;'</span>.<span class="keyword">format</span>(str1))</span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">str2 = <span class="string">','</span>.<span class="keyword">join</span>(str(i) <span class="keyword">for</span> i in arr)</span><br><span class="line">print(<span class="string">'str2 is &#123;&#125;'</span>.<span class="keyword">format</span>(str2))</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 is <span class="selector-tag">a</span>,b</span><br><span class="line">str2 is <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数组是在python中很常见，所以关于数组的知识点也相当重要。这篇博客是把工作中用到的知识点记录一下，持续更新中&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Flask-OAuth urlparse错误</title>
    <link href="http://yoursite.com/2018/12/13/Flask-OAuth-urlparse%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/12/13/Flask-OAuth-urlparse错误/</id>
    <published>2018-12-13T07:52:27.000Z</published>
    <updated>2018-12-13T07:58:38.402Z</updated>
    
    <content type="html"><![CDATA[<p>最近用到了Flash-OAuth的三方库，一运行，错误<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">File</span> <span class="string">"/Users/FQY/Desktop/bm_blog/blog/extensions.py"</span>, <span class="built_in">line</span> <span class="number">10</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    from flask_oauth <span class="keyword">import</span> OAuth</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/Users/FQY/env350/lib/python3.5/site-packages/flask_oauth.py"</span>, <span class="built_in">line</span> <span class="number">13</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    from urlparse <span class="keyword">import</span> parse</span><br><span class="line">ImportError: No <span class="keyword">module</span> named <span class="string">'urlparse'</span></span><br></pre></td></tr></table></figure></p><p>先说明下我用的python环境是<code>3.5.0</code>,百度下说是<code>from urlparse import urljoin</code> 是2.0的python用法，3.0的python用法已经urlparse已经被重新设置,所以进入三方库里面改下就可以了。<br>进入flask_oauth.py文件中进行修改<br><strong>原代码</strong><br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httplib2</span><br><span class="line"><span class="title">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="title">from</span> urlparse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="title">from</span> flask <span class="keyword">import</span> request, session, json, redirect, Response</span><br><span class="line"><span class="title">from</span> werkzeug <span class="keyword">import</span> url_decode, url_encode, url_quote, \</span><br><span class="line">     parse_options_header, <span class="type">Headers</span></span><br><span class="line"><span class="keyword">import</span> oauth2</span><br></pre></td></tr></table></figure></p><p><strong>修改以后的代码</strong><br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httplib2</span><br><span class="line"><span class="title">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="title">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="title">from</span> flask <span class="keyword">import</span> request, session, json, redirect, Response</span><br><span class="line"><span class="title">from</span> werkzeug <span class="keyword">import</span> url_decode, url_encode, url_quote, \</span><br><span class="line">     parse_options_header, <span class="type">Headers</span></span><br><span class="line"><span class="keyword">import</span> oauth2</span><br></pre></td></tr></table></figure></p><p>这时候在运行就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用到了Flash-OAuth的三方库，一运行，错误&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux tree:目录结构以树形显示</title>
    <link href="http://yoursite.com/2018/12/12/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%A5%E6%A0%91%E5%BD%A2%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/12/12/目录结构以树形显示/</id>
    <published>2018-12-12T06:51:20.000Z</published>
    <updated>2018-12-12T06:58:07.918Z</updated>
    
    <content type="html"><![CDATA[<p>有时候看到别人的目录结构是以树形显示，看到以后感觉很酷，所以自己就google了下，发现了很简单。</p><p><strong>实例</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY@bogon ~/Desktop/hello</span><br><span class="line">╰─$ tree </span><br><span class="line">.</span><br><span class="line">├── dong.txt</span><br><span class="line">├── dong_s<span class="selector-class">.txt</span> -&gt; dong.txt</span><br><span class="line">├── hell</span><br><span class="line">│   ├── hell</span><br><span class="line">│   │   └── hello</span><br><span class="line">│   └── hello</span><br><span class="line">├── hello</span><br><span class="line">├── hello1</span><br><span class="line">├── hello_s -&gt; hello</span><br><span class="line">└── tmd.rtf</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">8</span> files</span><br></pre></td></tr></table></figure></p><p>具体更多的关于tree的指令，后期在补充</p><p>未完接续。。。。。。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候看到别人的目录结构是以树形显示，看到以后感觉很酷，所以自己就google了下，发现了很简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux file命令:查看文件信息或类型</title>
    <link href="http://yoursite.com/2018/12/11/Linux-file%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%88%96%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/12/11/Linux-file命令-查看文件信息或类型/</id>
    <published>2018-12-11T08:32:25.000Z</published>
    <updated>2018-12-11T09:28:32.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux file命令用于辨识文件类型,通过file指令，我们得以辨识该文件的类型。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]<br><strong>参数</strong></p><ul><li>-b 　列出辨识结果时，不显示文件名称。</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li><li>-L 　直接显示符号连接所指向的文件的类别。</li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li><li>-v 　显示版本信息。</li><li>-z 　尝试去解读压缩文件的内容 (支持gzip类型)。</li><li>[文件或目录…]要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件</li></ul></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h5 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@hardwareupdate linux_test]</span># <span class="selector-tag">file</span> <span class="selector-tag">hello</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.txt</span>: <span class="selector-tag">UTF-8</span> <span class="selector-tag">Unicode</span> <span class="selector-tag">text</span></span><br></pre></td></tr></table></figure><p>使用不带任何选项的 file 命令，即可查看指定文件的类型信息。在上面的例子中可以看出 poetry.txt 的文件类型为 text，编码格式为 UTF-8。</p><p>使用<code>-b</code>就只显示编码和文件类型，不显示文件名<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hardwareupdate linux_test]# <span class="keyword">file</span> -b hello.txt</span><br><span class="line">UTF<span class="number">-8</span> Unicode <span class="keyword">text</span></span><br></pre></td></tr></table></figure></p><p>使用<code>-i</code>，咱们能看出什么?<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hardwareupdate linux_test]# <span class="keyword">file</span> -i hello.txt</span><br><span class="line">hello.txt: <span class="keyword">text</span>/plain; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><p><strong>常见的文件类型：</strong></p><ul><li>text/plain：普通文本。</li><li>text/html：HTML文本。</li><li>application/pdf：PDF文档。</li><li>application/msword：Word文档。</li><li>image/png：PNG图片。</li><li>mage/jpeg：JPEG图片。</li><li>application/x-tar：TAR文件。</li><li>application/x-gzip：GZIP文件</li></ul><h5 id="按照清单去工作"><a href="#按照清单去工作" class="headerlink" title="按照清单去工作"></a>按照清单去工作</h5><p>如果我们需要用 file 命令查看大量文件的类型信息，恰好这些文件的名称都被存储在了一个文本文件中，那么-f选项就派上用场了。我们可以通过-f选项来指定这个文本文件，file 命令就会乖乖地去逐个查看每一个文件的类型信息，示例如下:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#文件中含有三个待查文件, 我们故意设置了一个不存在的文件, 位于最后一个</span></span><br><span class="line">[roc@roclinux ~]$ cat poetry_list.txt</span><br><span class="line">/root/book/poetry.txt</span><br><span class="line">/root/book/poetry_s.txt</span><br><span class="line"><span class="literal">Nothing</span>.txt</span><br><span class="line"> </span><br><span class="line"><span class="meta">#使用-f选项执行file命令</span></span><br><span class="line">[roc@roclinux ~]$ file -f poetry_list.txt</span><br><span class="line">/root/book/poetry.txt:   ASCII <span class="keyword">text</span></span><br><span class="line">/root/book/poetry_s.txt: symbolic link <span class="keyword">to</span> `poetry.txt<span class="comment">'</span></span><br><span class="line"><span class="literal">Nothing</span>.txt: <span class="keyword">ERROR</span>: cannot open `<span class="literal">Nothing</span>.txt <span class="comment">' (No such file or directory)</span></span><br></pre></td></tr></table></figure></p><p>其他的各种指令，大家也可以去尝试，比如<code>-L</code>，当用软链接的时候不会直接返回文件类型，而是返回的是<code>symbolic link to XXX</code>，所以加<code>-L</code>就可以知道它是哪个类型了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/linux/file.html" target="_blank" rel="noopener">file命令_Linux file命令：查看文件信息或类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux file命令用于辨识文件类型,通过file指令，我们得以辨识该文件的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的HTTP状态码(HTTP Status Code)</title>
    <link href="http://yoursite.com/2018/12/11/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81-HTTP-Status-Code/"/>
    <id>http://yoursite.com/2018/12/11/常见的HTTP状态码-HTTP-Status-Code/</id>
    <published>2018-12-11T03:29:43.000Z</published>
    <updated>2018-12-11T03:37:29.901Z</updated>
    
    <content type="html"><![CDATA[<p>2开头 （请求成功）表示成功处理了请求的状态代码。<br>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求,流视频直播一般返回206</p><p>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><p>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2开头 （请求成功）表示成功处理了请求的状态代码。&lt;br&gt;200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。&lt;br&gt;201   （已创建）  请求成功并且服务器创建了新的资源。&lt;br&gt;202   （已接受）  服务器已接受请求，但尚未处理
      
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux文件管理之cmp、diff的使用详解</title>
    <link href="http://yoursite.com/2018/12/10/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%8Bcmp%E3%80%81diff%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/10/Linux文件管理之cmp、diff的使用详解/</id>
    <published>2018-12-10T03:41:40.000Z</published>
    <updated>2018-12-10T06:02:46.635Z</updated>
    
    <content type="html"><![CDATA[<p>cmp和diff都是用于比较两个文件的差异。但是两者的不同之处在于:</p><blockquote><p>cmp用于比较两个二进制文件，而diff主要用于比较两个文本文件<br><a id="more"></a></p></blockquote><h1 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h1><p>Linux cmp命令用于比较两个文件是否有差异。<br>当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>cmp [参数][文件1][文件2]</p></blockquote><p><strong>参数</strong></p><ul><li>-c或–print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。</li><li>-i&lt;字符数目&gt;或–ignore-initial=&lt;字符数目&gt; 　指定一个数目。</li><li>-l或–verbose 　标示出所有不一样的地方。</li><li>-s或–quiet或–silent 　不显示错误信息。</li><li>-v或–version 　显示版本信息。</li><li>–help 　在线帮助。<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp hello hello1   <span class="comment"># hello1是从hello复制的，然后在hello1添加了一些内容</span></span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp hello hello1   <span class="comment"># 出现EOF 是则 hello1 的第一部分与 hello 相同，但在 hello1 中还有其他数据</span></span><br><span class="line"><span class="symbol">cmp:</span> EOF on hello</span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp -l hello hello1 <span class="comment"># 这时候在hello中添加一些数据，在重新比较</span></span><br><span class="line"><span class="number">37</span> <span class="number">351</span> <span class="number">141</span></span><br><span class="line"><span class="number">38</span> <span class="number">230</span> <span class="number">163</span></span><br><span class="line"><span class="number">39</span> <span class="number">277</span> <span class="number">144</span></span><br><span class="line"><span class="number">40</span> <span class="number">346</span> <span class="number">146</span></span><br><span class="line"><span class="number">41</span> <span class="number">226</span> <span class="number">141</span></span><br><span class="line"><span class="symbol">cmp:</span> EOF on hello   </span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp  hello hello1                                                       <span class="number">1</span> ↵</span><br><span class="line">hello hello1 <span class="symbol">differ:</span> char <span class="number">37</span>, line <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h1><p>Linux diff命令用于比较文件的差异。<br>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><blockquote><p>diff[参数][文件1或目录1][文件2或目录2]</p></blockquote><p><strong>参数</strong></p><ul><li>-B或–ignore-blank-lines 　不检查空白行。</li><li>-c 　显示全部内文，并标出不同之处。</li><li>-C&lt;行数&gt;或–context&lt;行数&gt; 　与执行”-c-&lt;行数&gt;”指令相同。</li><li>-d或–minimal 　使用不同的演算法，以较小的单位来做比较。</li><li>-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。</li><li>-e或–ed 　此参数的输出格式可用于ed的script文件。</li><li>-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</li><li>-H或–speed-large-files 　比较大文件时，可加快速度。</li><li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</li><li>-i或–ignore-case 　不检查大小写的不同。</li><li>-l或–paginate 　将结果交由pr程序来分页。</li><li>-n或–rcs 　将比较结果以RCS的格式来显示。</li><li>-N或–new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：</li><li>Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</li><li>-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</li><li>-P或–unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</li><li>-q或–brief 　仅显示有无差异，不显示详细的信息。</li><li>-r或–recursive 　比较子目录中的文件。</li><li>-s或–report-identical-files 　若没有发现任何差异，仍然显示信息。</li><li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。</li><li>-t或–expand-tabs 　在输出时，将tab字符展开。</li><li>-T或–initial-tab 　在每行前面加上tab字符以便对齐。</li><li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。</li><li>-v或–version 　显示版本信息。</li><li>-w或–ignore-all-space 　忽略全部的空格字符。</li><li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。</li><li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。</li><li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。</li><li>-y或–side-by-side 　以并列的方式显示文件的异同之处。</li><li>–help 　显示帮助。</li><li>–left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li><li>–suppress-common-lines 　在使用-y参数时，仅显示不同之处。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">╭─FQY@bogon</span> <span class="string">~/Desktop/hello</span></span><br><span class="line"><span class="string">╰─$</span> <span class="string">diff</span> <span class="string">hello</span> <span class="string">hello1</span>                                                       <span class="number">1</span> <span class="string">↵</span></span><br><span class="line"><span class="number">4</span><span class="string">c4,5</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">python好用</span></span><br><span class="line"><span class="string">\</span> <span class="literal">No</span> <span class="string">newline</span> <span class="string">at</span> <span class="string">end</span> <span class="string">of</span> <span class="string">file</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&gt; node很方便</span></span><br><span class="line"><span class="string">&gt; 加油</span></span><br><span class="line"><span class="string">\ No newline at end of file </span></span><br><span class="line"><span class="string">╭─FQY@bogon ~/Desktop/hello</span></span><br><span class="line"><span class="string">╰─$ diff hello hello1 -y -W 50                                              2 ↵</span></span><br><span class="line"><span class="string">生活很美好       生活很美好</span></span><br><span class="line"><span class="string">现实很骨感       现实很骨感</span></span><br><span class="line"><span class="string">理想很丰富       理想很丰富</span></span><br><span class="line"><span class="string">python好用          \ node很方便</span></span><br><span class="line"><span class="string">              &gt; 加油%</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong><br>“|”表示前后2个文件内容有不同<br>“&lt;”表示后面文件比前面文件少了1行内容<br>“&gt;”表示后面文件比前面文件多了1行内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmp和diff都是用于比较两个文件的差异。但是两者的不同之处在于:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cmp用于比较两个二进制文件，而diff主要用于比较两个文本文件&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux cksum的使用详解</title>
    <link href="http://yoursite.com/2018/12/10/Linux-cksum%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/10/Linux-cksum的使用详解/</id>
    <published>2018-12-10T02:38:22.000Z</published>
    <updated>2018-12-10T02:55:23.341Z</updated>
    
    <content type="html"><![CDATA[<p>cksum命令是检查文件的CRC是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。这种方法要求校验和在源系统中被计算出来，在目的系统中又被计算一次，两个数字进行比较，如果校验和相等，则该文件被认为是正确传输了。<br>注意：CRC是指一种排错检查方法，即循环冗余校验法。<br>指定文件交由cksum命令进行校验后，会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为”-“，则cksum命令会从标准输入设备中读取数据。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>cksum [–help][–version][文件…]</p></blockquote><p><strong>参数</strong></p><ul><li>–help：在线帮助。</li><li>–version：显示版本信息。</li><li>文件…:需要进行检查的文件路径</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cksum hello  <span class="comment"># 命令执行后，将输出校验码等相关的信息</span></span><br><span class="line"><span class="number">4294967295</span> <span class="number">0</span> hello</span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>vim hello    <span class="comment"># 因为hello文件是空的，所以字节数为0，这时候给hello里面添加数据并保存</span></span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cksum hello  <span class="comment"># 再一次执行命令，这时候看到字节数是36。"4090568956"表示校验码</span></span><br><span class="line"><span class="number">4090568956</span> <span class="number">36</span> hello</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果文件中有任何字符被修改，都将改变计算后CRC校验码的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cksum命令是检查文件的CRC是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。这种方法要求校验和在源系统中被计算出来，在目的系统中又被计算一次，两个数字进行比较，如果校验和相等，则该文件被认为是正确传输了。&lt;br&gt;注意：CRC是指一种排错检查方法，即循环冗余
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 系统目录结构</title>
    <link href="http://yoursite.com/2018/12/07/Linux-%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2018/12/07/Linux-系统目录结构/</id>
    <published>2018-12-07T07:52:20.000Z</published>
    <updated>2018-12-07T08:11:41.488Z</updated>
    
    <content type="html"><![CDATA[<p>登录系统后，在当前命令窗口下输入命令：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@hardwareupdate ~]</span># <span class="selector-tag">ls</span></span><br><span class="line"><span class="selector-tag">git</span>           <span class="selector-tag">log</span>        <span class="selector-tag">mysqlbkup</span><span class="selector-class">.sh</span>  <span class="selector-tag">pip-9</span><span class="selector-class">.0</span><span class="selector-class">.1</span>                       <span class="selector-tag">Python-3</span><span class="selector-class">.4</span><span class="selector-class">.1</span>  <span class="selector-tag">s3fs-fuse</span> <span class="selector-tag">anaconda-ks</span><span class="selector-class">.cfg</span>  <span class="selector-tag">get-pip</span><span class="selector-class">.py</span>    <span class="selector-tag">install</span><span class="selector-class">.log</span><span class="selector-class">.syslog</span>  <span class="selector-tag">mewe</span><span class="selector-class">.bak1</span>  <span class="selector-tag">nohup</span><span class="selector-class">.out</span>     <span class="selector-tag">pip-9</span><span class="selector-class">.0</span><span class="selector-class">.1-py2</span><span class="selector-class">.py3-none-any</span><span class="selector-class">.whl</span>  <span class="selector-tag">Python-3</span><span class="selector-class">.6</span><span class="selector-class">.2</span> </span><br><span class="line"><span class="selector-attr">[root@hardwareupdate ~]</span>#</span><br></pre></td></tr></table></figure></p><p><strong>树状目录结构</strong></p><p><img src="http://www.runoob.com/wp-content/uploads/2014/06/003vPl7Rty6E8kZRlAEdc690.jpg" alt=""></p><p>以下是对这些目录的解释：</p><ul><li>/bin：<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>/boot：<br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/dev ：<br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li>/etc：<br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li>/home：<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>/lib：<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li>/lost+found：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/media：<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>/mnt：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li>/opt：<br>这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>/proc：<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li>/root：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/sbin：<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li>/selinux：<br>这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</li><li>/srv：<br>该目录存放一些服务启动之后需要提取的数据。</li><li><p>/sys：</p><p>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</p></li></ul><p>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。<br>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p><ul><li>/tmp：<br>这个目录是用来存放一些临时文件的。</li><li>/usr：<br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li>/usr/bin：<br>系统用户使用的应用程序。</li><li>/usr/sbin：<br>超级用户使用的比较高级的管理程序和系统守护程序。</li><li>/usr/src：<br>内核源代码默认的放置目录。</li><li>/var：<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>/run：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li></ul><p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。<br>/etc：上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。<br>/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在/bin/ls 目录下的。<br>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给root使用的指令。</p><p>/var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在/var/log 目录下，另外mail的预设放置也是在这里</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;登录系统后，在当前命令窗口下输入命令：&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux 修改文件权限命令chmod、chgrp、chown详解</title>
    <link href="http://yoursite.com/2018/12/07/%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4chmod%E3%80%81chgrp%E3%80%81chown%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/07/修改文件权限命令chmod、chgrp、chown详解/</id>
    <published>2018-12-07T03:39:55.000Z</published>
    <updated>2018-12-07T07:51:26.374Z</updated>
    
    <content type="html"><![CDATA[<p>Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。<br>文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。<br><a id="more"></a><br>有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。</p><h1 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h1><p>chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>chmod [-cfvR] [–help] [–version] mode file…</p></blockquote><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>mode : 权限设定字串，格式如下 :</p><blockquote><p>[ugoa…][[+-=][rwxX]…][,…]</p></blockquote><p>其中</p><ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li><li>+表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X<br>表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<ul><li>r(Read，读取，权限值为4)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目 录的权限</li><li>w(Write,写入，权限值为2)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。</li><li>x(eXecute，执行，权限值为1)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。</li></ul></li></ul><p>其他参数说明：</p><ul><li>-c : 若该文件权限确实已经更改，才显示其更改动作</li><li>-f : 若该文件权限无法被更改也不要显示错误讯息</li><li>-v : 显示权限变更的详细资料</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在桌面创建一个hello的文件夹，里面有一个hello的文件。<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY@bogon ~/Desktop</span><br><span class="line">╰─$ ll  | grep hello                                                     </span><br><span class="line">drwxr-xr-x  <span class="number"> 3 </span>FQY  staff    96B<span class="number"> 12 </span><span class="number"> 7 </span>11:55 hello</span><br><span class="line">╭─FQY@bogon ~/Desktop</span><br><span class="line">╰─$ cd hello</span><br><span class="line">╭─FQY@bogon ~/Desktop/hello</span><br><span class="line">╰─$ ll  | grep hello</span><br><span class="line">-rw-r--r-- <span class="number"> 1 </span>FQY  staff     0B<span class="number"> 12 </span><span class="number"> 7 </span>11:55 hello</span><br></pre></td></tr></table></figure></p><p>咱们首先看<code>hello</code>文件夹，是<code>drwxr-xr-x</code>, <code>d</code>表示是文件夹,如果不是文件夹，则第一个是<code>-</code>。咱们上面说到有3种用户类型:文件所有者，同组用户、其他用户.<code>rwx</code>表示文件所有者的权限，<code>r-x</code>表示同组用户的权限,<code>r-x</code>表示其他用户。</p><p>根据上面所说的那样，<strong>r</strong>为4，<strong>w</strong>为2，<strong>x</strong>为1，所以<code>rwx</code>就是7，<code>r-x</code>表示5，所以当咱们需要让同组和其他用户都可以对<code>hello.rtf</code>有读写的权利,<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>chmod <span class="number">766</span> hello</span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>ll  | grep hello</span><br><span class="line">-rwxrw-rw-  <span class="number">1</span> FQY  staff     0B <span class="number">12</span>  <span class="number">7</span> <span class="number">11</span><span class="symbol">:</span><span class="number">55</span> hello</span><br></pre></td></tr></table></figure></p><p>下面来举些例子熟悉下:</p><table><thead><tr><th>权限</th><th>数值</th></tr></thead><tbody><tr><td>-rwxrw-r–-</td><td>764</td></tr><tr><td>-rw-r–-r–-</td><td>644</td></tr><tr><td>-rw-rw-r–-</td><td>664</td></tr></tbody></table><p>创建一个file1.text文件，将文件 file1.txt 设为所有人皆可读取:</p><blockquote><p>chmod ugo+r file1.txt</p></blockquote><p>将文件 file1.txt 设为所有人皆可读取 :</p><blockquote><p>chmod a+r file1.txt</p></blockquote><p>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p><blockquote><p>chmod ug+w,o-w file1.txt file2.txt</p></blockquote><p>所以咱们晓得:<br><code>chmod ug=rwx,o=x file</code> 和 <code>chmod 771 file</code>，效果是一样的。</p><h1 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h1><blockquote><p>Linux chgrp命令用于变更文件或目录的所属群组。</p></blockquote><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><blockquote><p>chgrp [选项] [组] [文件]</p></blockquote><p>参数说明:<br>    -c或–changes 效果类似”-v”参数，但仅回报更改的部分。　　<br>    -f或–quiet或–silent 　不显示错误信息。<br>    -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。<br>    -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。<br>    -v或–verbose 　显示指令执行过程。<br>    –help 　在线帮助。<br>    –reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。<br>    –version 　显示版本信息。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>将log2012.log文件由root群组改为bin群组</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@localhost</span> test]<span class="meta"># ll</span></span><br><span class="line">---xrw-r-- <span class="number">1</span> root root <span class="number">302108</span> <span class="number">11</span><span class="number">-13</span> <span class="number">06</span>:<span class="number">03</span> log2012.<span class="built_in">log</span></span><br><span class="line">[root<span class="symbol">@localhost</span> test]<span class="meta"># chgrp -v bin log2012.log</span></span><br><span class="line">“log2012.<span class="built_in">log</span>” 的所属组已更改为 bin</span><br><span class="line">[root<span class="symbol">@localhost</span> test]<span class="meta"># ll</span></span><br><span class="line">---xrw-r-- <span class="number">1</span> root bin  <span class="number">302108</span> <span class="number">11</span><span class="number">-13</span> <span class="number">06</span>:<span class="number">03</span> log2012.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><strong>根据指定文件改变文件的群组属性</strong></p><p>改变文件log2013.log的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]<span class="comment"># ll</span></span><br><span class="line">---xrw-r--<span class="number"> 1 </span>root bin <span class="number"> 302108 </span>11-13 06:03 log2012.log</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root root    <span class="number"> 61 </span>11-13 06:03 log2013.log</span><br><span class="line">[root@localhost test]<span class="comment">#  chgrp --reference=log2012.log log2013.log </span></span><br><span class="line">[root@localhost test]<span class="comment"># ll</span></span><br><span class="line">---xrw-r--<span class="number"> 1 </span>root bin <span class="number"> 302108 </span>11-13 06:03 log2012.log</span><br><span class="line">-rw-r--r--<span class="number"> 1 </span>root bin     <span class="number"> 61 </span>11-13 06:03 log2013.log</span><br></pre></td></tr></table></figure><h1 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h1><p>使用权限: root</p><p>使用方式 : chown [-cfhvR] [–help] [–version] user[:group] file… </p><p>说明 : Linux/Unix 是多人多工作业系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥<br>有者加以改变。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以<br>改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才<br>有这样的权限。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code>user : 新的档案拥有者的使用者 IDgroup : 新的档案拥有者的使用者群体(group)-c或-change：作用与-v相似，但只传回修改的部分 -f或–quiet或–silent：不显示错误信息 -h或–no-dereference：只对符号链接的文件做修改，而不更改其他任何相关文件 -R或-recursive：递归处理，将指定目录下的所有文件及子目录一并处理 -v或–verbose：显示指令执行过程 –dereference：作用和-h刚好相反 –help：显示在线说明 –reference=&lt;参考文件或目录&gt;：把指定文件或目录的所有者与所属组，统统设置成和参考文件或目录的所有者与所属组相同 –version：显示版本信息</code></pre><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>将文件 file1.txt 的拥有者设为 users 群体的使用者 runoob :</p><blockquote><p>chown runoob:users file1.txt</p></blockquote><p>将目前目录下的所有文件与子目录的拥有者皆设为 users 群体的使用者 lamport :</p><blockquote><p>chown -R lamport:users *</p></blockquote><h1 id="chmod和chown的区别"><a href="#chmod和chown的区别" class="headerlink" title="chmod和chown的区别"></a>chmod和chown的区别</h1><blockquote><p>chmod与chown看似拼写还有点差不多，但是两者的用途是不同的。chmod是用来设置文件夹和文件权限的，比如我们在VPS主机中文件不可读写，需要用来设置777权限；而chown是用来设置用户组的，比如授权某用户组，方便控制用户权限。</p></blockquote><p><strong>chown 修改文件和文件夹的用户和用户组属性</strong><br>1。要修改文件hh.c的所有者.修改为sakia的这个用户所有</p><blockquote><p>chown sakia hh.c</p></blockquote><p>这样就把hh.c的用户访问权限应用到sakia作为所有者</p><p>2。将目录 /tmp/sco 这个目录的所有者和组改为sakia和组net</p><blockquote><p>chown -R sakia:net /tmp/sco</p></blockquote><p><strong>chmod 修改文件和文件夹读写执行属性</strong></p><p>1。把hh.c文件修改为可写可读可执行</p><blockquote><p>chmod 777 hh.c</p></blockquote><p>要修改某目录下所有的文件属性为可写可读可执行</p><blockquote><p>chmod 777 <em>.</em></p></blockquote><p>把文件夹名称与后缀名用*来代替就可以了。 </p><p>同理若是要修改所有htm文件的属性</p><blockquote><p>chmod 777 *.htm</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。&lt;br&gt;文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下chattr命令详解</title>
    <link href="http://yoursite.com/2018/12/05/linux%E4%B8%8Bchattr%E3%80%81chgrp%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/05/linux下chattr、chgrp命令详解/</id>
    <published>2018-12-05T09:04:13.000Z</published>
    <updated>2018-12-05T09:36:22.434Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>chattr 可以修改文件属性</p></blockquote><p>有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。chattr命令的作用很大，通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。lsattr命令是显示chattr命令设置的文件属性</p><h3 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h3><p>lsattr命令是显示chattr命令设置的文件属性<br><a id="more"></a></p><h3 id="chattr和chmod的区别"><a href="#chattr和chmod的区别" class="headerlink" title="chattr和chmod的区别"></a>chattr和chmod的区别</h3><p>这两个命令是用来查看和改变文件、目录属性的，与chmod这个命令相比，chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>chattr [-RV][-v&lt;版本编号&gt;][+/-/=&lt;属性&gt;][文件或目录…]</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><blockquote></blockquote><pre><code>+ ：在原有参数设定基础上，追加参数。- ：在原有参数设定基础上，移除参数。= ：更新为指定参数设定。A：文件或目录的 atime (access time)不可被修改(modified), 可以有效预防例如手提电脑磁盘I/O错误的发生。S：硬盘I/O同步选项，功能类似sync。a：即append，设定该参数后，只能向文件中添加数据，而不能删除，多用于服务器日志文件安全，对于日志系统很好用，这个权限让目标文件只能追加，不能删除，而且不能通过编辑器追加。c：即compresse，设定文件是否经压缩后再存储。读取时需要经过自动解压操作。d：即no dump，设定文件不能成为dump程序的备份目标。i：设定文件不能被删除、改名、设定链接关系，同时不能写入或新增内容。i参数对于文件 系统的安全设置有很大帮助。j：即journal，设定此参数使得当通过mount参数：data=ordered 或者 data=writeback 挂 载的文件系统，文件在写入时会先被记录(在journal中)。如果filesystem被设定参数为 data=journal，则该参数自动失效。s：保密性地删除文件或目录，即硬盘空间被全部收回。u：与s相反，当设定为u时，数据内容其实还存在磁盘中，可以用于undeletion。各参数选项中常用到的是a和i。a选项强制只可添加不可删除，多用于日志系统的安全设定。而i是更为严格的安全设定，只有superuser (root) 或具有CAP_LINUX_IMMUTABLE处理能力（标识）的进程能够施加该选项</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><pre><code>-R 递归处理，将指定目录下的所有文件及子目录一并处理。-v&lt;版本编号&gt; 设置文件或目录版本。-V 显示指令执行过程。+&lt;属性&gt; 开启文件或目录的该项属性。-&lt;属性&gt; 关闭文件或目录的该项属性。=&lt;属性&gt; 指定文件或目录的该项属性</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">╭─root@iz ~</span><br><span class="line">╰─# <span class="keyword">ls</span> </span><br><span class="line">hello.<span class="keyword">conf</span>   # 我在下面创建一个hello.<span class="keyword">conf</span>文件</span><br><span class="line">╭─root@iz~</span><br><span class="line">╰─# chattr -V +i  hello.<span class="keyword">conf</span>   # 设定文件不能被删除、改名等</span><br><span class="line">chattr 1.42.9 (28-<span class="keyword">Dec</span>-2013)</span><br><span class="line">hello.<span class="keyword">conf</span>的标志被设为 ----i--------<span class="keyword">e</span>--</span><br><span class="line">╭─root@iz ~</span><br><span class="line">╰─# <span class="keyword">rm</span> hello.<span class="keyword">conf</span></span><br><span class="line"><span class="keyword">rm</span>: 无法删除<span class="string">"hello.conf"</span>: 不允许的操作</span><br><span class="line">╭─root@iz ~</span><br><span class="line">╰─# lsattr hello.<span class="keyword">conf</span>   # 用lsattr 可以查看chattr下面的设置</span><br><span class="line">----i--------<span class="keyword">e</span>-- hello.<span class="keyword">conf</span></span><br><span class="line">╭─root@iz ~</span><br><span class="line">╰─# lsattr hello.<span class="keyword">conf</span></span><br><span class="line">----i--------<span class="keyword">e</span>-- hello.<span class="keyword">conf</span></span><br><span class="line">╭─root@iz ~</span><br><span class="line">╰─# chattr -V -i hello.<span class="keyword">conf</span></span><br><span class="line">chattr 1.42.9 (28-<span class="keyword">Dec</span>-2013)</span><br><span class="line">hello.<span class="keyword">conf</span>的标志被设为 -------------<span class="keyword">e</span>--</span><br><span class="line">这时候在删除就可以删除了</span><br><span class="line">╭─root@iz ~</span><br><span class="line">╰─# <span class="keyword">rm</span> hello.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;chattr 可以修改文件属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。chattr命令的作用很大，通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。lsattr命令是显示chattr命令设置的文件属性&lt;/p&gt;
&lt;h3 id=&quot;lsattr&quot;&gt;&lt;a href=&quot;#lsattr&quot; class=&quot;headerlink&quot; title=&quot;lsattr&quot;&gt;&lt;/a&gt;lsattr&lt;/h3&gt;&lt;p&gt;lsattr命令是显示chattr命令设置的文件属性&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>python 批量上传文件到阿里云oss，并写入Excel，存到本地</title>
    <link href="http://yoursite.com/2018/11/29/python-%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91oss/"/>
    <id>http://yoursite.com/2018/11/29/python-批量上传文件到阿里云oss/</id>
    <published>2018-11-29T05:59:03.000Z</published>
    <updated>2018-11-29T07:43:02.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近公司要往阿里云oss上传视频，大小差不多有200G，原先让运营去一个一个的添加，但是这能麻烦死人，所以就让技术去批量上传。所以研究了一下用python往oss上传视频<br><a id="more"></a></p></blockquote><p>首先需引用以下几个模块<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> oss2</span><br><span class="line">pip <span class="keyword">install</span> tablib</span><br><span class="line">pip <span class="keyword">install</span> pyexcel-xlsx</span><br></pre></td></tr></table></figure></p><p>其次因为本地的视频都是比如<code>中文.mp4</code>这样的，所以引入一个随机字符串<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_random_str</span><span class="params">(randomlength=<span class="number">8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成一个指定长度的随机字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    random_str = <span class="string">''</span></span><br><span class="line">    base_str = <span class="string">'ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789'</span></span><br><span class="line">    length = len(base_str) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(randomlength):</span><br><span class="line">        random_str += base_str[random.randint(<span class="number">0</span>, length)]</span><br><span class="line">    <span class="keyword">return</span> random_str</span><br></pre></td></tr></table></figure></p><p>因为是文件夹里面套文件夹，但是只上传文件，所以需要获取子文件夹下面的视频<br><img src="https://upload-images.jianshu.io/upload_images/2120155-938d3901bc70ab14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>代码如下：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def upload(dir):</span><br><span class="line">    fs = os.listdir(dir)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fs:</span><br><span class="line">        <span class="built_in">file</span> = dir + <span class="string">"/"</span> + f</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(<span class="built_in">file</span>):</span><br><span class="line">            upload(<span class="built_in">file</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'DS_Store'</span> <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">file</span> <span class="keyword">and</span> <span class="string">'png'</span> <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">and</span> <span class="string">'JPG'</span> <span class="keyword">not</span> <span class="keyword">in</span> f:</span><br><span class="line">                putAliyun(<span class="built_in">file</span>, f)</span><br></pre></td></tr></table></figure></p><p><strong>备注</strong>：因为文件夹里面还有图片，所以去除后缀为<code>png</code>、<code>JPG</code>的图片。因为用的是mac上传，所以文件夹里面有<code>.DS_Store</code>，所以也需要去除</p><p>所以这个的整个代码如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># ! -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> tablib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">ossDir = <span class="string">'/Users/FQY/Desktop/upload'</span></span><br><span class="line">key = XXX</span><br><span class="line">secret = XXX</span><br><span class="line">bucketname = XXX</span><br><span class="line"></span><br><span class="line">dataset = tablib.Dataset()</span><br><span class="line">header = (<span class="string">'title'</span>, <span class="string">'url'</span>)</span><br><span class="line">dataset.headers = header</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_random_str</span><span class="params">(randomlength=<span class="number">8</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成一个指定长度的随机字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    random_str = <span class="string">''</span></span><br><span class="line">    base_str = <span class="string">'ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789'</span></span><br><span class="line">    length = len(base_str) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(randomlength):</span><br><span class="line">        random_str += base_str[random.randint(<span class="number">0</span>, length)]</span><br><span class="line">    <span class="keyword">return</span> random_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getmkname</span><span class="params">(path)</span>:</span></span><br><span class="line">    remoteName = path.replace(ossDir, <span class="string">''</span>)</span><br><span class="line">    dir_names = remoteName.split(<span class="string">'/'</span>)</span><br><span class="line">    dir_names.pop()</span><br><span class="line">    res = filter(<span class="keyword">None</span>, dir_names)</span><br><span class="line">    mkdir_name = <span class="string">'-'</span>.join(res)</span><br><span class="line">    <span class="keyword">return</span> mkdir_name</span><br><span class="line"></span><br><span class="line"><span class="comment">#获得上传的时长</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">progress_callback</span><span class="params">(bytes_consumed, total_bytes)</span>:</span></span><br><span class="line">    print(<span class="string">'bytes_consumed is &#123;&#125;'</span>.format(bytes_consumed))</span><br><span class="line">    print(<span class="string">'total_bytes is &#123;&#125;'</span>.format(total_bytes))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">putAliyun</span><span class="params">(path, f)</span>:</span></span><br><span class="line">    key = <span class="string">'language/'</span> + str(int(time.time())) + generate_random_str() + <span class="string">'.mp4'</span></span><br><span class="line">    auth = oss2.Auth(key, secret)</span><br><span class="line">    bucket = oss2.Bucket(auth, <span class="string">'http://oss-cn-hangzhou.aliyuncs.com'</span>, bucketname)</span><br><span class="line">    result = bucket.put_object_from_file(key=key, filename=path,progress_callback=progress_callback)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.status == <span class="number">200</span>:</span><br><span class="line">        aliyun = <span class="string">'http://mewevideo.oss-cn-hangzhou.aliyuncs.com/&#123;&#125;'</span>.format(key)</span><br><span class="line">        title = <span class="string">'【&#123;&#125;】&#123;&#125;'</span>.format(getmkname(path), f.split(<span class="string">'.mp4'</span>)[<span class="number">0</span>])</span><br><span class="line">        dataset.append([title, aliyun])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'upload fail,error code'</span>, result.status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(dir)</span>:</span></span><br><span class="line">    fs = os.listdir(dir)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fs:</span><br><span class="line">        file = dir + <span class="string">"/"</span> + f</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(file):</span><br><span class="line">            upload(file)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'DS_Store'</span> <span class="keyword">not</span> <span class="keyword">in</span> file <span class="keyword">and</span> <span class="string">'png'</span> <span class="keyword">not</span> <span class="keyword">in</span> f <span class="keyword">and</span> <span class="string">'JPG'</span> <span class="keyword">not</span> <span class="keyword">in</span> f:</span><br><span class="line">                putAliyun(file, f)</span><br><span class="line"></span><br><span class="line">upload(ossDir)</span><br><span class="line"></span><br><span class="line">myfile = open(<span class="string">'/Users/FQY/Desktop/mydata_video.xlsx'</span>, <span class="string">'wb'</span>)</span><br><span class="line">myfile.write(dataset.xlsx)</span><br><span class="line">myfile.close()</span><br></pre></td></tr></table></figure></p><p>tablib的介绍，可以观看以下的文章<br><br><a href="https://blog.gideondudu.com/2018/10/31/%E5%88%A9%E7%94%A8tablib%E3%80%81make-response-%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8B%E8%BD%BD/" target="_blank" rel="noopener">利用tablib、make_response 进行文件的下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近公司要往阿里云oss上传视频，大小差不多有200G，原先让运营去一个一个的添加，但是这能麻烦死人，所以就让技术去批量上传。所以研究了一下用python往oss上传视频&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>sudo -s 切换到root账户</title>
    <link href="http://yoursite.com/2018/11/20/sudo-s-%E5%88%87%E6%8D%A2%E5%88%B0root%E8%B4%A6%E6%88%B7/"/>
    <id>http://yoursite.com/2018/11/20/sudo-s-切换到root账户/</id>
    <published>2018-11-20T09:50:31.000Z</published>
    <updated>2018-11-20T09:51:22.647Z</updated>
    
    <content type="html"><![CDATA[<p>sudo su 和 sudo -s都是切换到root用户，不同的是：</p><blockquote><p>sudo su 环境用的是目标用户(root)的环境<br>sudo -s 环境用的是当前用户本身的环境</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sudo su 和 sudo -s都是切换到root用户，不同的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;sudo su 环境用的是目标用户(root)的环境&lt;br&gt;sudo -s 环境用的是当前用户本身的环境&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>ubuntu系统下gitlab的创建</title>
    <link href="http://yoursite.com/2018/11/20/ubuntu%E7%B3%BB%E7%BB%9F%E4%B8%8Bgitlab%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/11/20/ubuntu系统下gitlab的创建/</id>
    <published>2018-11-20T08:37:22.000Z</published>
    <updated>2018-11-20T09:36:44.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘要： gitlab的介绍、环境、创建步骤、关键点、卸载gitlab<br><a id="more"></a></p></blockquote><h1 id="gitlab的介绍"><a href="#gitlab的介绍" class="headerlink" title="gitlab的介绍"></a>gitlab的介绍</h1><blockquote><p>GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。</p></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>ubuntu 18.04LTS</p></blockquote><h1 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h1><p>gitlab官网上面有在ubuntu创建gitlab的步骤<br><a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">https://about.gitlab.com/install/</a> 可以点击按照步骤来做</p><h1 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h1><p>每次修改配置的时候记得<code>sudo gitlab-ctl reconfigure</code>，使配置生效</p><p><strong>指令</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">查看运行状态</span><br><span class="line">    sudo gitlab-ctl status</span><br><span class="line">启动所有 gitlab 组件</span><br><span class="line">    sudo gitlab-ctl <span class="keyword">start</span> </span><br><span class="line">停止所有 gitlab 组件   </span><br><span class="line">    sudo gitlab-ctl <span class="keyword">stop</span>       </span><br><span class="line">重启所有 gitlab 组件 </span><br><span class="line">    sudo gitlab-ctl restart  </span><br><span class="line">启动服务      </span><br><span class="line">    sudo gitlab-ctl reconfigure </span><br><span class="line">修改默认的配置文件       </span><br><span class="line">    sudo vim /etc/gitlab/gitlab.rb    </span><br><span class="line">检查gitlab    </span><br><span class="line">    gitlab-rake gitlab:<span class="keyword">check</span> SANITIZE=<span class="literal">true</span> <span class="comment">--trace  </span></span><br><span class="line">查看日志  </span><br><span class="line">    sudo gitlab-ctl tail</span><br></pre></td></tr></table></figure></p><p><strong>初始账户和密码</strong><br>有的笔记上说的默认账户和密码是下面的</p><blockquote><p>账户：root<br>密码：5iveL!fe</p></blockquote><p>但是我打开网页的时候，直接提示的是 change your password。这时候我做的就是把密码修改下，密码最少8个字，当你修改过了以后你就可以登录了。比如：</p><blockquote><p>账户：root<br>密码：xxkh1234</p></blockquote><h1 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h1><p>1、停止gitlab<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-ctl <span class="built_in">stop</span></span><br></pre></td></tr></table></figure></p><p>2、卸载gitlab（注意这里写的是gitlab-ce）<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo dpkg -r gitlab-ce</span></span><br></pre></td></tr></table></figure></p><p>3、查看gitlab进程<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> gitlab</span><br></pre></td></tr></table></figure></p><p><img src="http://blog.whsir.com/wp-content/uploads/2017/05/gitlab.png" alt=""><br>4、杀掉第一个进程（就是带有好多………….的进程）<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill <span class="number">-9</span> <span class="number">18777</span></span><br></pre></td></tr></table></figure></p><p>杀掉后，在ps aux | grep gitlab确认一遍，还有没有gitlab的进程</p><p>5、删除所有包含gitlab文件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> / -name gitlab | xargs rm -rf</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘要： gitlab的介绍、环境、创建步骤、关键点、卸载gitlab&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux grep、tail命令的混合使用</title>
    <link href="http://yoursite.com/2018/11/14/Linux-grep%E3%80%81tail%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/11/14/Linux-grep、tail命令的使用/</id>
    <published>2018-11-14T06:06:29.000Z</published>
    <updated>2018-11-14T07:32:57.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>Linux grep命令用于查找文件里符合条件的字符串。<br>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]</p></blockquote><p>或</p><blockquote><p>grep [选项] “模式” [文件]</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><blockquote><ul><li>-a 或 –text : 不要忽略二进制的数据。</li><li>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li><li>-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li><li>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li>-c 或 –count : 计算符合样式的列数。</li><li>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li>-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。</li><li>-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。</li><li>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li>-F 或 –fixed-regexp : 将样式视为固定字符串的列表。</li><li>-G 或 –basic-regexp : 将样式视为普通的表示法来使用。</li><li>-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li><li>-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li><li>-i 或 –ignore-case : 忽略字符大小写的差别。</li><li>-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。</li><li>-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。</li><li>-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li>-q 或 –quiet或–silent : 不显示任何信息。</li><li>-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。</li><li>-s 或 –no-messages : 不显示错误信息。</li><li>-v 或 –revert-match : 显示不包含匹配文本的所有行。</li><li>-V 或 –version : 显示版本信息。</li><li>-w 或 –word-regexp : 只显示全字符合的列。</li><li>-x –line-regexp : 只显示全列符合的列。</li><li>-y : 此参数的效果和指定”-i”参数相同</li></ul></blockquote><p><strong>实例</strong><br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@hard supervisord]# grep <span class="string">'POST.*play_order.*return 200'</span> tmd.log</span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-21</span> <span class="number">14</span>:<span class="number">39</span>:<span class="number">21</span>,<span class="number">190</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-21</span> <span class="number">14</span>:<span class="number">42</span>:<span class="number">03</span>,<span class="number">327</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-21</span> <span class="number">14</span>:<span class="number">43</span>:<span class="number">27</span>,<span class="number">720</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-21</span> <span class="number">18</span>:<span class="number">15</span>:<span class="number">25</span>,<span class="number">090</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-21</span> <span class="number">18</span>:<span class="number">33</span>:<span class="number">20</span>,<span class="number">517</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-22</span> <span class="number">16</span>:<span class="number">20</span>:<span class="number">55</span>,<span class="number">863</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">36</span>,<span class="number">183</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">52</span>:<span class="number">44</span>,<span class="number">021</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br><span class="line">[<span class="number">2018</span><span class="number">-10</span><span class="number">-22</span> <span class="number">17</span>:<span class="number">55</span>:<span class="number">15</span>,<span class="number">172</span>] [base.py:<span class="number">451</span>  ] [<span class="symbol">DEBUG</span>] [<span class="symbol">POST</span> /adminapi/v3/play_order ] return <span class="number">200</span></span><br></pre></td></tr></table></figure></p><p><code>grep &#39;POST.*play_order.*return 200&#39; tmd.log</code> 这个等同于<code>grep  &#39;play_order&#39; tmd.log  | grep &#39;POST&#39; | grep &#39;return 200&#39;</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@hard supervisord]# <span class="keyword">grep</span> -<span class="keyword">c</span> <span class="string">'POST.*play_order.*return 200'</span> tmd.<span class="built_in">log</span></span><br><span class="line"><span class="number">62</span></span><br><span class="line">[root@hard supervisord]# <span class="keyword">grep</span> -<span class="keyword">c</span>  <span class="string">'play_order'</span> tmd.<span class="built_in">log</span>  | <span class="keyword">grep</span> <span class="string">'POST'</span> | <span class="keyword">grep</span> <span class="string">'return 200'</span></span><br><span class="line">[root@hard supervisord]# <span class="keyword">grep</span>  <span class="string">'play_order'</span> tmd.<span class="built_in">log</span>  | <span class="keyword">grep</span> <span class="string">'POST'</span> | <span class="keyword">grep</span> -<span class="keyword">c</span> <span class="string">'return 200'</span></span><br><span class="line"><span class="number">62</span></span><br></pre></td></tr></table></figure><p>grep可以和很多的命令一起使用<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查看Linux 某些程序进程 ps aux </span><br><span class="line">[root@iZ2ze3269b etc]<span class="comment"># ps aux | grep mysql</span></span><br><span class="line">root     <span class="number"> 2371 </span> 0.0  0.0<span class="number"> 112676 </span> <span class="number"> 980 </span>pts/0    S+   14:34   0:00 grep --color=auto mysql</span><br><span class="line">mysql   <span class="number"> 10810 </span> 0.1  9.4<span class="number"> 1599384 </span>367788 ?      Sl   10月11  13:13 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure></p><h1 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h1><p>tail 命令可用于查看文件的内容，有一个常用的参数 -f 常用于查阅正在改变的日志文件。<br>tail -f filename 会把 filename 文件里的最尾部的内容显示在屏幕上，并且不断刷新，只要 filename 更新就可以看到最新的文件内容。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><blockquote><p>tail [参数] [文件]  </p></blockquote><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><blockquote><ul><li>-f 循环读取</li><li>-q 不显示处理信息</li><li>-v 显示详细的处理信息</li><li>-c&lt;数目&gt; 显示的字节数</li><li>-n&lt;行数&gt; 显示行数</li><li>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.</li><li>-q, –quiet, –silent 从不输出给出文件名的首部</li><li>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒</li></ul></blockquote><p><strong>实例</strong></p><p>要显示 notes.log 文件的最后 10 行，请输入以下命令：</p><blockquote><p>tail notes.log</p></blockquote><p>要跟踪名为 notes.log 的文件的增长情况，请输入以下命令：</p><blockquote><p>tail -f notes.log</p></blockquote><p>此命令显示 notes.log 文件的最后 10 行。当将某些行添加至 notes.log 文件时，tail 命令会继续显示这些行。 显示一直继续，直到您按下（Ctrl-C）组合键停止显示。<br>显示文件 notes.log 的内容，从第 20 行至文件末尾:</p><blockquote><p>tail +20 notes.log</p></blockquote><h1 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h1><p>有时候我们会查询正在改变的文件，但是我们只想查看其中的某一些信息，这时候就可以使用tail、grep的混合使用</p><blockquote><p>tail -f filename | grep ‘DEBUG’ </p></blockquote><p><strong>实例</strong></p><blockquote><p>tail -f tmd.log | grep ‘DEBUG.<em>template.</em>begin’</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a&gt;grep&lt;/h1&gt;&lt;p&gt;Linux grep命令用于查找文件里符合条件的字符串。&lt;br&gt;grep指令用于查找内容包含指定的范本样式的文件，如果发现某
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>vim 指令</title>
    <link href="http://yoursite.com/2018/11/14/vim-%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/11/14/vim-指令/</id>
    <published>2018-11-14T02:24:25.000Z</published>
    <updated>2018-11-14T02:27:12.337Z</updated>
    
    <content type="html"><![CDATA[<h3 id="上下左右"><a href="#上下左右" class="headerlink" title="上下左右"></a>上下左右</h3><p><code>h, j, k , l</code>四个键分别代表方向键<code>← ↓ ↑ →</code> ，也就是上下左右，每次只能向上、向左、向右、向下一下。<br>如果向下移动5行的话，可以用数字+快捷键<code>5j</code>,那么向右移动5个就是<code>5l</code>。</p><a id="more"></a><h3 id="翻页"><a href="#翻页" class="headerlink" title="翻页"></a>翻页</h3><p>组合键</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ctrl</span>&gt;</span> + f  向下移动一页 </span><br><span class="line"><span class="tag">&lt;<span class="name">ctrl</span>&gt;</span> + d  向下移动半页</span><br><span class="line"><span class="tag">&lt;<span class="name">ctrl</span>&gt;</span> + b  向上移动一页</span><br><span class="line"><span class="tag">&lt;<span class="name">ctrl</span>&gt;</span> + u  向上移动半页</span><br></pre></td></tr></table></figure><h3 id="行首行尾"><a href="#行首行尾" class="headerlink" title="行首行尾"></a>行首行尾</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>   <span class="comment">#快速跳到行首</span></span><br><span class="line"><span class="variable">$ </span>  <span class="comment">#快速调到行尾</span></span><br><span class="line">g<span class="number">_</span>  <span class="comment">#快速跳到行尾最后一个非空字符</span></span><br></pre></td></tr></table></figure><h3 id="页头页尾"><a href="#页头页尾" class="headerlink" title="页头页尾"></a>页头页尾</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gg</span> <span class="comment">#快速跳到第一行</span></span><br><span class="line">G  <span class="comment">#快速跳到最后一行</span></span><br></pre></td></tr></table></figure><h3 id="行内查找"><a href="#行内查找" class="headerlink" title="行内查找"></a>行内查找</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fx     #从当前光标开始向右查找字符 <span class="keyword">x</span>，<span class="keyword">x</span> 为目标字符</span><br><span class="line">nfx    #从当前广告开始向右查找第 n 个字符 <span class="keyword">x</span>，n 为数字</span><br><span class="line">Fx     #从当前光标开始向左查找字符 <span class="keyword">x</span>，<span class="keyword">x</span> 为目标字符</span><br><span class="line">nfx    #从当前广告开始向左查找第 n 个字符 <span class="keyword">x</span>，n 为数字</span><br></pre></td></tr></table></figure><h3 id="全文查找"><a href="#全文查找" class="headerlink" title="全文查找"></a>全文查找</h3><p>如果你想要把全文的 native 都找到，可以按下 / 进入 command 模式，随后输入 native 然后回车，此时光标会定位在第一个目标上，并高亮所有找到的目标单词。此时按下 n 光标就会向下在高亮的单词上依次跳转，N 则会反方向跳转。</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/word   <span class="string">" 输入 / 会进入 command 模式，再输入先要搜索的单词并回车进行搜索</span></span><br><span class="line">?word   <span class="string">" / 是向光标以后搜索，? 是向前搜索</span></span><br><span class="line">n       <span class="string">" 英文字母 n，根据 / 或 ? 搜索的方向定位到下一个匹配目标</span></span><br><span class="line">N       <span class="string">" 与 n 相反，定位匹配目标</span></span><br></pre></td></tr></table></figure><h3 id="复制、粘贴、删除"><a href="#复制、粘贴、删除" class="headerlink" title="复制、粘贴、删除"></a>复制、粘贴、删除</h3><p>复制当前行 <code>yy</code>，删除并复制当前行 <code>dd</code>，粘贴到光标下一行 <code>p</code></p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dd          <span class="string">" 删除当前行</span></span><br><span class="line">ndd         <span class="string">" 向下删除 n 行</span></span><br><span class="line">d1G / dgg   <span class="string">" 删除第一行到当前行的数据</span></span><br><span class="line">dG          <span class="string">" 删除当前行到最后一行的数据</span></span><br><span class="line">d$          <span class="string">" 删除当前字符到行尾</span></span><br><span class="line">d0          <span class="string">" 从行首删除到当前字符</span></span><br><span class="line">yy          <span class="string">" 复制当前行</span></span><br><span class="line">nyy         <span class="string">" 从当前行开始复制 n 行</span></span><br><span class="line">y1G / ygg   <span class="string">" 从第一行复制到当前行</span></span><br><span class="line">yG          <span class="string">" 从当前行复制到最后一行</span></span><br><span class="line">y0          <span class="string">" 从行首复制到当前字符</span></span><br><span class="line">y$          <span class="string">" 从当前字符复制到行尾</span></span><br><span class="line">p, P        <span class="string">" 黏贴，p 黏贴到光标下一行，P 黏贴到光标上一行</span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x        <span class="string">" 向后删除一个字符</span></span><br><span class="line">nx       <span class="string">" 向后删除 n 个字符</span></span><br><span class="line">X        <span class="string">" 向前删除一个字符</span></span><br><span class="line">nX       <span class="string">" 向前删除 n 个字符</span></span><br></pre></td></tr></table></figure><h3 id="撤销和重做"><a href="#撤销和重做" class="headerlink" title="撤销和重做"></a>撤销和重做</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">u</span>       <span class="comment">" 撤销</span></span><br><span class="line"><span class="symbol">&lt;c-r&gt;</span>   <span class="comment">" 重做</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;上下左右&quot;&gt;&lt;a href=&quot;#上下左右&quot; class=&quot;headerlink&quot; title=&quot;上下左右&quot;&gt;&lt;/a&gt;上下左右&lt;/h3&gt;&lt;p&gt;&lt;code&gt;h, j, k , l&lt;/code&gt;四个键分别代表方向键&lt;code&gt;← ↓ ↑ →&lt;/code&gt; ，也就是上下左右，每次只能向上、向左、向右、向下一下。&lt;br&gt;如果向下移动5行的话，可以用数字+快捷键&lt;code&gt;5j&lt;/code&gt;,那么向右移动5个就是&lt;code&gt;5l&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Vim" scheme="http://yoursite.com/categories/Vim/"/>
    
    
  </entry>
  
</feed>
