<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小小看护</title>
  
  <subtitle>守护自己，守护家人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-26T05:53:44.725Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小小看护</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python encode和decode函数的用法</title>
    <link href="http://yoursite.com/2019/02/26/python-encode%E5%92%8Cdecode%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2019/02/26/python-encode和decode函数的用法/</id>
    <published>2019-02-26T03:53:16.000Z</published>
    <updated>2019-02-26T05:53:44.725Z</updated>
    
    <content type="html"><![CDATA[<p>从英文意思上看，encode和decode分别指编码和解码。在python中，Unicode类型是作为编码的基础类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">     encode                 decode</span><br><span class="line"><span class="built_in">str</span> ---------&gt; Unicode ---------&gt; <span class="built_in">str</span></span><br></pre></td></tr></table></figure></p><pre><code>encode的作用是将其他编码的字符串转换成unicode编码，如str1.encode(&apos;gb2312&apos;)，表示将gb2312编码的字符串str1转换成unicode编码。 decode的作用是将unicode编码转换成其他编码的字符串，如str2.decode(&apos;gb2312&apos;)，表示将unicode编码的字符串str2转换成gb2312编码</code></pre><p><code>因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码</code><br>下面咱们用几个例子来看下:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'中国，你好'</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'type is &#123;&#125;'</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(s)))</span><br><span class="line"># 用encode进行编码</span><br><span class="line">s1 = s.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'s1 is &#123;&#125;'</span>.<span class="built_in">format</span>(s1))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'type is &#123;&#125;'</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(s1)))</span><br><span class="line"># 用decode进行编码</span><br><span class="line">s2 = s1.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'s2 is &#123;&#125;'</span>.<span class="built_in">format</span>(s2))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'type is &#123;&#125;'</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(s2)))</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'str'</span>&gt;</span><br><span class="line">s1 <span class="keyword">is</span> b<span class="string">'\xe4\xb8\xad\xe5\x9b\xbd\xef\xbc\x8c\xe4\xbd\xa0\xe5\xa5\xbd'</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'bytes'</span>&gt;</span><br><span class="line">s2 <span class="keyword">is</span> 中国，你好</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>看完运行结果大家就知道怎么用了。😆</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从英文意思上看，encode和decode分别指编码和解码。在python中，Unicode类型是作为编码的基础类型。&lt;br&gt;&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>爬虫系列之urllib的使用</title>
    <link href="http://yoursite.com/2019/02/25/%E7%88%AC%E8%99%AB%E7%B3%BB%E5%88%97-urllib%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/25/爬虫系列-urllib的使用/</id>
    <published>2019-02-25T08:03:36.000Z</published>
    <updated>2019-02-26T03:07:41.166Z</updated>
    
    <content type="html"><![CDATA[<p>urllib库是python爬虫中的常用库，这个库来说，我们不需要关心请求的链接是什么，需要传的参数是什么，以及如何设置可选的请求头就好了，不用深入到底层去了解它到底是怎样的传输和通信的。有了它，两行代码就可以完成一个请求和相应的处理过程，得到网页。<br><a id="more"></a></p><h1 id="urllib的模块"><a href="#urllib的模块" class="headerlink" title="urllib的模块"></a>urllib的模块</h1><p>urllib包含4个模块：<br>    <code>request</code>:它是最基本的HTTP请求模块，可以用了模拟发送请求<br>    <code>error</code>:异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。<br>    <code>parse</code>:一个工具模块，提供了许多URL处理方法，比如拆分、解析、合并等。<br>    <code>rebotparser</code>:主要是用来识别网站的rebots.txt文件，然后判断哪些网站可以爬，哪些网站不可以爬，实际用的不多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;urllib库是python爬虫中的常用库，这个库来说，我们不需要关心请求的链接是什么，需要传的参数是什么，以及如何设置可选的请求头就好了，不用深入到底层去了解它到底是怎样的传输和通信的。有了它，两行代码就可以完成一个请求和相应的处理过程，得到网页。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>hexo 添加本地图片</title>
    <link href="http://yoursite.com/2019/02/14/hexo-%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2019/02/14/hexo-添加本地图片/</id>
    <published>2019-02-14T03:15:30.000Z</published>
    <updated>2019-02-14T03:47:59.453Z</updated>
    
    <content type="html"><![CDATA[<p>hexo插入图片的方式有好几种，链接或者本地图片，介于链接图片有可能失效的原因，用本地图片是最省事的，目前插入本地图片有两种方式。</p><ul><li>跟随文章的创建图片文件夹</li><li>创建总的图片文件夹<a id="more"></a><h1 id="跟随文章的创建方式"><a href="#跟随文章的创建方式" class="headerlink" title="跟随文章的创建方式"></a>跟随文章的创建方式</h1><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4>根目录下的配置文件_config.yml里的post_asset_folder选项设置为true。新建文章的时候会同时创建一个同名文件夹用于放图片。<h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4>执行命令<code>npm install hexo-asset-image --save</code> ，下载安装一个可以上传本地图片的插件。<br>使用的时候，只需要图片名就可以 <code>![](test.jpg)</code><br><strong>例如</strong>我创建的这篇文章，<code>hexo 添加本地图片</code><br><img src="/2019/02/14/hexo-添加本地图片/1550115421513.jpg" alt=""><br>然后下面就生成了相应的文件夹，这个文件夹下面存放相应的图片。<br><img src="/2019/02/14/hexo-添加本地图片/1550115487994.jpg" alt=""><br>这时候我只需要引用<code>![](1550115421513.jpg)</code>就可以了。</li></ul><h1 id="创建总的图片文件夹"><a href="#创建总的图片文件夹" class="headerlink" title="创建总的图片文件夹"></a>创建总的图片文件夹</h1><p>在主题的 source 下面新建一个 文件夹（比如uploads）用于专门放置这些图片资源。<br>使用的时候使用<code>![](/uploads/test.jpg)</code>的方式。</p><p>PS:你可以根据自己的爱好去选择。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hexo插入图片的方式有好几种，链接或者本地图片，介于链接图片有可能失效的原因，用本地图片是最省事的，目前插入本地图片有两种方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跟随文章的创建图片文件夹&lt;/li&gt;
&lt;li&gt;创建总的图片文件夹&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>git push github失败，提示SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</title>
    <link href="http://yoursite.com/2019/02/13/git-push-github%E5%A4%B1%E8%B4%A5%EF%BC%8C%E6%8F%90%E7%A4%BASSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443/"/>
    <id>http://yoursite.com/2019/02/13/git-push-github失败，提示SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443/</id>
    <published>2019-02-13T09:03:06.000Z</published>
    <updated>2019-02-13T09:06:46.605Z</updated>
    
    <content type="html"><![CDATA[<p>今天git push 发现出现错误，很莫名其妙，错误的详情如下:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fata<span class="variable">l:</span> unable <span class="keyword">to</span> access <span class="string">'https://github.com/XXXX/XXXX.git/'</span>: </span><br><span class="line">LibreSSL SSL_connec<span class="variable">t:</span> SSL_ERROR_SYSCALL in connection <span class="keyword">to</span> github.<span class="keyword">com</span>:<span class="number">443</span></span><br></pre></td></tr></table></figure></p><p>然后去网上根据这个错误提示搜了一下，发现是因为Git的Http代理的问题，Git支持三种协议：git://、ssh://和http://，本来push的时候应该走ssh隧道的，但是因为设置了http代理，所以就走了http的代理，于是就提交不了了。<br>OK，找到原因了，那就取消http代理吧：</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在github项目在本地的根目录下打开git命令行，<br>执行下面的命令<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global --unset http.proxy</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天git push 发现出现错误，很莫名其妙，错误的详情如下:&lt;br&gt;&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx https 证书配置</title>
    <link href="http://yoursite.com/2019/02/12/nginx-https-%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/12/nginx-https-证书配置/</id>
    <published>2019-02-12T10:47:58.000Z</published>
    <updated>2019-02-12T11:17:10.099Z</updated>
    
    <content type="html"><![CDATA[<p>使用<code>https</code>需要配置SSL证书,因为我使用的阿里云，所以下面是阿里云的配置<br><a id="more"></a></p><h1 id="域名解析到服务器"><a href="#域名解析到服务器" class="headerlink" title="域名解析到服务器"></a>域名解析到服务器</h1><p><img src="https://upload-images.jianshu.io/upload_images/2120155-75e80c50ad68a36d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务器ip设置.png"></p><h1 id="申请ca证书"><a href="#申请ca证书" class="headerlink" title="申请ca证书"></a>申请ca证书</h1><p>在阿里云控制台-产品与服务-安全(云盾)-CA证书服务(数据安全)，点击购买证书<br><img src="https://upload-images.jianshu.io/upload_images/2120155-0cf7dcf151d4b1e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="免费证书.png"><br>选择“免费版DV SSL”，点击立即购买:<br><img src="http://upload-images.jianshu.io/upload_images/2120155-fe1efa0d69767d4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="免费证书.png"><br>然后点去支付:<br><img src="http://upload-images.jianshu.io/upload_images/2120155-75725ac45e2fd02a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="免费证书.png"><br>最后确认支付:<br><img src="http://upload-images.jianshu.io/upload_images/2120155-de55bd8685494a4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="免费证书.png"><br>就会回到管理界面,然后根据说明去配置。<strong>说明：因为我们这里申请的是开发版免费证书，所以一个证书仅支持一个域名认证，不支持通配符。</strong><br>等待几分钟，证书状态变为“已签发”后，证书就申请成功了。</p><h1 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h1><p>列表中找到已签发的证书，下载, 下载的时候选择Nginx。<br>然后把相应的正式传到服务器,命令方法使用<code>scp</code>。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>scp -r root<span class="variable">@43</span>.<span class="number">224.34</span>.<span class="number">73</span><span class="symbol">:/home/lk</span> /root</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/tianhei/p/7726505.html" target="_blank" rel="noopener">nginx配置ssl证书实现https访问</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用&lt;code&gt;https&lt;/code&gt;需要配置SSL证书,因为我使用的阿里云，所以下面是阿里云的配置&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx http和https配置</title>
    <link href="http://yoursite.com/2019/02/12/nginx-http%E5%92%8Chttps%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/02/12/nginx-http和https配置/</id>
    <published>2019-02-12T10:23:28.000Z</published>
    <updated>2019-02-12T11:07:10.458Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="nginx配置详解"><a href="#nginx配置详解" class="headerlink" title="nginx配置详解"></a>nginx配置详解</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 全局配置</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"></span><br><span class="line">user www-data;             <span class="comment">## 配置 worker 进程的用户和组</span></span><br><span class="line">worker_processes auto;     <span class="comment">## 配置 worker 进程启动的数量，建议配置为 CPU 核心数</span></span><br><span class="line">error_log logs/<span class="keyword">error</span>.<span class="built_in">log</span>;  <span class="comment">## 全局错误日志</span></span><br><span class="line">pid /<span class="built_in">run</span>/nginx.pid;        <span class="comment">## 设置记录主进程 ID 的文件</span></span><br><span class="line">worker_rlimit_nofile <span class="number">8192</span>; <span class="comment">## 配置一个工作进程能够接受并发连接的最大数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># 工作模式及连接数上限</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">events &#123;</span><br><span class="line">    <span class="comment"># epoll 是多路复用 IO（I/O Multiplexing）中的一种方式，</span></span><br><span class="line">    <span class="comment"># 仅用于 Linux 2.6 以上内核，可以大大提高 Nginx 性能</span></span><br><span class="line">    use epoll</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 单个后台 worker process 进程的最大并发链接数</span></span><br><span class="line">    <span class="comment"># 并发总数 max_clients = worker_professes * worker_connections</span></span><br><span class="line">    worker_connections <span class="number">4096</span>;  <span class="comment">## Defaule: 1024</span></span><br><span class="line">    <span class="comment"># multi_accept on;  ## 指明 worker 进程立刻接受新的连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># http 模块</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># Basic Settings</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，</span></span><br><span class="line">    <span class="comment">#对于普通应用，必须设为 on,</span></span><br><span class="line">    <span class="comment">#如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，</span></span><br><span class="line">    <span class="comment">#以平衡磁盘与网络 I/O 处理速度，降低系统的 uptime.</span></span><br><span class="line">    sendfile <span class="keyword">on</span>;</span><br><span class="line">    tcp_nopush <span class="keyword">on</span>;</span><br><span class="line">    tcp_nodelay <span class="keyword">on</span>;</span><br><span class="line">    keepalive_timeout <span class="number">65</span>;      <span class="comment">## 连接超时时间</span></span><br><span class="line">    types_hash_max_size <span class="number">2048</span>;  <span class="comment">## 指定散列类型表的最大大小</span></span><br><span class="line">    <span class="comment"># server_tokens off;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># server_names_hash_bucket_size 64;  # this seems to be required for some vhosts</span></span><br><span class="line">    <span class="comment"># server_name_in_redirect off;</span></span><br><span class="line">    </span><br><span class="line">    include /etc/nginx/mime.types;  <span class="comment">## 设定 mine 类型</span></span><br><span class="line">    default_type <span class="built_in">application</span>/octet-stream;</span><br><span class="line">   </span><br><span class="line">    <span class="comment"># 设定请求缓冲</span></span><br><span class="line">    client_header_buffer_size    <span class="number">128</span>k; <span class="comment"># 指定客户端请求头缓存大小，当请求头大于 1KB 时会用到该项</span></span><br><span class="line">    large_client_header_buffers  <span class="number">4</span> <span class="number">128</span>k; <span class="comment"># 最大数量和最大客户端请求头的大小</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># SSL Settings</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启用所有协议，禁用已废弃的不安全的SSL 2 和SSL 3</span></span><br><span class="line">    ssl_protocols TLSv1 TLSv1<span class="number">.1</span> TLSv1<span class="number">.2</span>; <span class="comment"># Dropping SSLv3, ref: POODLE</span></span><br><span class="line">    <span class="comment"># 让服务器选择要使用的算法套件</span></span><br><span class="line">    ssl_prefer_server_ciphers <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># Logging Settings</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">    access_log /var/<span class="built_in">log</span>/nginx/access.<span class="built_in">log</span>;  <span class="comment">## 访问日志</span></span><br><span class="line">    error_log /var/<span class="built_in">log</span>/nginx/<span class="keyword">error</span>.<span class="built_in">log</span>;    <span class="comment">## 错误日志</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># Gzip Settings</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">    gzip <span class="keyword">on</span>;</span><br><span class="line">    gzip_disable <span class="string">"msie6"</span>;</span><br><span class="line">    <span class="built_in">text</span>/xml <span class="built_in">application</span>/xml <span class="built_in">application</span>/xml+rss <span class="built_in">text</span>/javascript;</span><br><span class="line"></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line">    <span class="comment"># Virtual Host Configs</span></span><br><span class="line">    <span class="comment">##</span></span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;   <span class="comment"># 这个文件夹默认是空的</span></span><br><span class="line">    include /etc/nginx/sites-enabled/*; <span class="comment"># 开启的 Server 服务配置</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">##</span></span><br><span class="line"><span class="comment"># mail 模块</span></span><br><span class="line"><span class="comment">##</span></span><br><span class="line">        </span><br><span class="line">mail &#123;</span><br><span class="line">    <span class="comment"># See sample authentication script at:</span></span><br><span class="line">    <span class="comment"># http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># auth_http localhost/auth.php;</span></span><br><span class="line">    <span class="comment"># pop3_capabilities "TOP" "USER";</span></span><br><span class="line">    <span class="comment"># imap_capabilities "IMAP4rev1" "UIDPLUS";</span></span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen     localhost:<span class="number">110</span>;</span><br><span class="line">        protocol   pop3;</span><br><span class="line">        proxy      <span class="keyword">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen     localhost:<span class="number">143</span>;</span><br><span class="line">        protocol   imap;</span><br><span class="line">        proxy      <span class="keyword">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结来说</strong><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">main：用于进行nginx全局信息的配置</span><br><span class="line">events：用于nginx工作模式的配置</span><br><span class="line"><span class="keyword">http</span>：用于进行<span class="keyword">http</span>协议信息的一些配置</span><br><span class="line">server：用于进行服务器访问信息的配置</span><br><span class="line">location：用于进行访问路由的配置</span><br><span class="line">upstream：用于进行负载均衡的配置</span><br></pre></td></tr></table></figure></p><h1 id="目前使用的一些nginx配置"><a href="#目前使用的一些nginx配置" class="headerlink" title="目前使用的一些nginx配置"></a>目前使用的一些nginx配置</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For more information on configuration, see:</span></span><br><span class="line"><span class="comment">#   * Official English Documentation: http://nginx.org/en/docs/</span></span><br><span class="line"><span class="comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#user nginx;</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">2</span>;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="comment">#worker_rlimit_nofile 65535;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load dynamic modules. See /usr/share/nginx/README.dynamic.</span></span><br><span class="line"><span class="comment">#include /usr/share/nginx/modules/*.conf;</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Load modular configuration files from the /etc/nginx/conf.d directory.</span></span><br><span class="line">    <span class="comment"># See http://nginx.org/en/docs/ngx_core_module.html#include</span></span><br><span class="line">    <span class="comment"># for more information.</span></span><br><span class="line">    <span class="comment"># include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这段是只http的时候设置的</span></span><br><span class="line">    <span class="comment">#***************************************************************************</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">        <span class="comment">#listen       80;</span></span><br><span class="line">    <span class="comment">#server_name localhost;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># root         /usr/share/nginx/html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="comment">#include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#location / &#123;</span></span><br><span class="line">        <span class="comment">#proxy_pass http://localhost:8080;</span></span><br><span class="line">        <span class="comment">#proxy_set_header Host $host;</span></span><br><span class="line">        <span class="comment">#proxy_set_header X-Real-IP $remote_addr;</span></span><br><span class="line">        <span class="comment">#proxy_set_header X-Scheme $scheme;</span></span><br><span class="line">        <span class="comment">#proxy_pass_header Server;</span></span><br><span class="line">        <span class="comment">#proxy_redirect on;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">    <span class="comment">#***************************************************************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这段是只https的时候设置的</span></span><br><span class="line">    <span class="comment">#***************************************************************************</span></span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>   XXX.XXXX.com;</span><br><span class="line">        <span class="attribute">return</span>        <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span>;</span><br><span class="line">        <span class="attribute">server_name</span>   XXX.XXXX.com;</span><br><span class="line">        <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">ssl_certificate</span>   cert/XXX.XXXX.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  cert/XXX.XXXX.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /&#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://localhost:8080;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-NginX-Proxy <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">#****************************************************************************</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;nginx配置详解&quot;&gt;&lt;a href=&quot;#nginx配置详解&quot; class=&quot;headerlink&quot; title=&quot;nginx配置详解&quot;&gt;&lt;/a&gt;nginx配置详解&lt;/h1&gt;&lt;figure class=&quot;highlight ap
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx http 强制跳转 https 地址</title>
    <link href="http://yoursite.com/2019/02/12/Nginx-http-%E5%BC%BA%E5%88%B6%E8%B7%B3%E8%BD%AC-https-%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/2019/02/12/Nginx-http-强制跳转-https-地址/</id>
    <published>2019-02-12T10:18:42.000Z</published>
    <updated>2019-02-12T11:07:04.543Z</updated>
    
    <content type="html"><![CDATA[<p><code>https</code> 越来越普及，但是当用户自己访问 <code>http</code> 是控制不了的，所以强制跳转的功能就必不可少了，下面是几种强制跳转的方法<br><a id="more"></a></p><h1 id="return-301"><a href="#return-301" class="headerlink" title="return 301"></a>return 301</h1><p>返回 301 错误，并跳转到 https 地址<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  wxnacy.com;</span><br><span class="line">    <span class="attribute">return</span>       <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br></pre></td></tr></table></figure><p>两者相比，301 的方式在搜索引擎速度上要块一些。</p><h1 id="error-page-497"><a href="#error-page-497" class="headerlink" title="error_page 497"></a>error_page 497</h1><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">error </span>code 497: normal request was sent to HTTPS</span><br></pre></td></tr></table></figure><p>在一个站点只允许 https 访问时, 如果使用 http 访问会报出497错误码<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_page</span> <span class="number">497</span>  https://<span class="variable">$host</span><span class="variable">$uri</span>?<span class="variable">$args</span>;</span><br></pre></td></tr></table></figure></p><h1 id="index-html-refresh"><a href="#index-html-refresh" class="headerlink" title="index.html refresh"></a>index.html refresh</h1><p>百度页面 <a href="http://baidu.com" target="_blank" rel="noopener">http://baidu.com</a> 自动跳转 <a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> 是灵活利用了 meta 的刷新属性<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; $ curl http://baidu.com</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">meta</span>&gt;</span>html&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;https&lt;/code&gt; 越来越普及，但是当用户自己访问 &lt;code&gt;http&lt;/code&gt; 是控制不了的，所以强制跳转的功能就必不可少了，下面是几种强制跳转的方法&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>nginx的基本使用</title>
    <link href="http://yoursite.com/2019/02/12/nginx%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/12/nginx的基本使用/</id>
    <published>2019-02-12T09:39:48.000Z</published>
    <updated>2019-02-12T11:07:07.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。<strong>它最常的用途是提供反向代理服务。</strong>关于nginx的安装，网上有很多教程，大家都可以去百度上查找。这篇文章是来记录nginx的基本使用和配置中遇到的错误问题。<br><a id="more"></a></p></blockquote><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p><strong>环境配置</strong><br>将命令脚本超链接到环境变量中<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ln -sf <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx /u</span>sr<span class="regexp">/local/</span>bin<span class="regexp">/nginx</span></span><br></pre></td></tr></table></figure></p><p><strong>启动</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nginx</span><br></pre></td></tr></table></figure></p><p><strong>停止</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -s [<span class="literal">start</span>, <span class="literal">stop</span>]</span><br></pre></td></tr></table></figure></p><p><strong>重新启动</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nginx -s reopen</span><br></pre></td></tr></table></figure></p><p><strong>修改 nginx.conf 后进行测试是否没有语法错误</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nginx -t</span><br></pre></td></tr></table></figure></p><p><strong>然后重新加载配置，使之生效</strong><br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>nginx -s reload</span><br></pre></td></tr></table></figure></p><p><strong>系统命令的方式来启动停止</strong><br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl [<span class="literal">start</span>, <span class="literal">stop</span>, restart] nginx</span><br></pre></td></tr></table></figure></p><p><strong>设置是否自动开机自启动</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo systemctl [<span class="built_in">enable</span>, <span class="built_in">disable</span>] nginx</span></span><br></pre></td></tr></table></figure></p><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><p>1、nginx: [error] invalid PID number “” in “/run/nginx.pid”<br><code>nginx -s reload</code> 报<code>nginx: [error] invalid PID number &quot;&quot; in &quot;/run/nginx.pid&quot;</code>错误<br>遇到这个错误，需要先执行<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nginx -c <span class="regexp">/etc/</span>nginx<span class="regexp">/nginx.conf</span></span><br></pre></td></tr></table></figure></p><p>nginx.conf文件的路径可以从nginx -t的返回中找到。<br>这时候如何没有报错，那么你就可以<code>nginx -s reload</code><br>如果还错误,请看第二个问题<br>2、nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)<br>错误详情<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nginx: [emerg] bind() <span class="keyword">to</span> 0.0.0.0:80 failed (98:<span class="built_in"> Address </span>already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] bind() <span class="keyword">to</span> 0.0.0.0:80 failed (98:<span class="built_in"> Address </span>already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] bind() <span class="keyword">to</span> 0.0.0.0:80 failed (98:<span class="built_in"> Address </span>already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] bind() <span class="keyword">to</span> 0.0.0.0:80 failed (98:<span class="built_in"> Address </span>already <span class="keyword">in</span> use)</span><br><span class="line">nginx: [emerg] still could <span class="keyword">not</span> bind()</span><br></pre></td></tr></table></figure></p><p>错误描述：地址已被使用。可能nginx服务卡死了，导致端口占用。<br>查看nginx的运行情况<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">ps</span> aux | <span class="keyword">grep</span> nginx</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root     13332  0.0  0.0  56824  2796 ?        Ss   17:00   0:00 nginx: master process nginx -c /etc/nginx/nginx.conf</span><br><span class="line">nginx    13437  0.0  0.0  57360  3792 ?        S    17:09   0:00 nginx: worker process</span><br><span class="line">nginx    13438  0.0  0.0  57228  3776 ?        S    17:09   0:00 nginx: worker process</span><br><span class="line">root     13854  0.0  0.0 112676   992 pts/0    S+   18:09   0:00 grep <span class="attribute">--color</span>=auto <span class="attribute">--exclude-dir</span>=.bzr <span class="attribute">--exclude-dir</span>=CVS <span class="attribute">--exclude-dir</span>=.git <span class="attribute">--exclude-dir</span>=.hg <span class="attribute">--exclude-dir</span>=.svn nginx</span><br></pre></td></tr></table></figure></p><p>使用<code>kill</code>指令删除进程<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill <span class="number">-9</span> <span class="number">13332</span> <span class="number">13437</span> <span class="number">13438</span></span><br></pre></td></tr></table></figure></p><p>然后<code>nginx -s reload</code>刷新<br>3、nginx绑定域名，发现使用域名访问不成功，用ip访问成功<br>出现这种情况一般是因为你的服务器安全组没有设置相应的端口访问，比如<code>http</code>，需要设置<code>80</code>端口可以访问,<code>https</code>设置<code>443</code>端口。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。&lt;strong&gt;它最常的用途是提供反向代理服务。&lt;/strong&gt;关于nginx的安装，网上有很多教程，大家都可以去百度上查找。这篇文章是来记录nginx的基本使用和配置中遇到的错误问题。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>学习nginx遇到的一些问题</title>
    <link href="http://yoursite.com/2019/01/15/%E5%AD%A6%E4%B9%A0nginx%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/01/15/学习nginx遇到的一些问题/</id>
    <published>2019-01-15T10:41:47.000Z</published>
    <updated>2019-01-15T10:45:36.022Z</updated>
    
    <content type="html"><![CDATA[<h3 id="nginx-找不到安装地址"><a href="#nginx-找不到安装地址" class="headerlink" title="nginx 找不到安装地址"></a>nginx 找不到安装地址</h3><p>今天看到了nginx,想到我在服务器里面安装了nginx，只是还没有用到，所以想看下其安装地址，却没有找到，后来谷歌下，发现用<code>nginx -t</code>就可以找到nginx.conf的文件位置，从而知道nginx的安装位置。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># nginx -t</span><br><span class="line">nginx: the configuration <span class="keyword">file</span> /etc/nginx/nginx.<span class="keyword">conf</span> <span class="keyword">syntax</span> <span class="keyword">is</span> ok</span><br><span class="line">nginx: configuration <span class="keyword">file</span> /etc/nginx/nginx.<span class="keyword">conf</span> test <span class="keyword">is</span> successful</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;nginx-找不到安装地址&quot;&gt;&lt;a href=&quot;#nginx-找不到安装地址&quot; class=&quot;headerlink&quot; title=&quot;nginx 找不到安装地址&quot;&gt;&lt;/a&gt;nginx 找不到安装地址&lt;/h3&gt;&lt;p&gt;今天看到了nginx,想到我在服务器里面安装了ngi
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Python基础系列之*args和**kwargs的认识</title>
    <link href="http://yoursite.com/2019/01/06/Python%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E4%B9%8B-args%E5%92%8C-kwargs/"/>
    <id>http://yoursite.com/2019/01/06/Python基础系列之-args和-kwargs/</id>
    <published>2019-01-06T14:46:05.000Z</published>
    <updated>2019-01-06T15:02:47.347Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>*args和**kwargs这两个参数咱们经常用到，今天在巩固基础的时候，看到了这两个参数，做了一下对比，所以记录一下。</p></blockquote><h3 id="args"><a href="#args" class="headerlink" title="*args"></a>*args</h3><p>*args这种写法代表的是 <strong>元组</strong>，就比如我上面为啥说它们是参数，是因为他们经常在函数的参数中出现。<br>下面咱们在例子中来说明<br><a id="more"></a><br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getTupleParameter(x, *<span class="keyword">args</span>):</span><br><span class="line">    <span class="keyword">print</span>('x is &#123;&#125;'.<span class="keyword">format</span>(x)) </span><br><span class="line">    <span class="keyword">print</span>('<span class="keyword">args</span> is &#123;&#125;'.<span class="keyword">format</span>(<span class="keyword">args</span>))</span><br><span class="line">    <span class="keyword">print</span>('<span class="keyword">type</span> is &#123;&#125;'.<span class="keyword">format</span>(<span class="keyword">type</span>(<span class="keyword">args</span>)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">args</span>:</span><br><span class="line">        <span class="keyword">print</span>('i is &#123;&#125;'.<span class="keyword">format</span>(i))</span><br><span class="line"></span><br><span class="line">getTupleParameter(1, 2, 3, 4, 5, 6, 7)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>('*'*100)</span><br><span class="line">getTupleParameter(1)</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">args <span class="keyword">is</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br><span class="line">i <span class="keyword">is</span> <span class="number">2</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">3</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">4</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">5</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">6</span></span><br><span class="line">i <span class="keyword">is</span> <span class="number">7</span></span><br><span class="line">********************************************************************</span><br><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">args <span class="keyword">is</span> ()</span><br><span class="line"><span class="keyword">type</span> <span class="keyword">is</span> &lt;<span class="keyword">class</span> <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a>**kwargs</h3><p>*kwargs这种写法代表的是 <strong>字典</strong>，下面咱们在例子中来说明<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def getDictParameter(x, **kwargs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x is &#123;&#125;'</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'kwargs is &#123;&#125;'</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'type is &#123;&#125;'</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(kwargs)))</span><br><span class="line"></span><br><span class="line">getDictParameter(<span class="number">1</span>, a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)</span><br><span class="line">getDictParameter(<span class="number">1</span>)</span><br><span class="line">res = dict(</span><br><span class="line">    a=<span class="number">1</span>,</span><br><span class="line">    b=<span class="number">2</span>,</span><br><span class="line">    c=<span class="number">3</span></span><br><span class="line">)</span><br><span class="line">getDictParameter(<span class="number">1</span>, **res)</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="type">is </span>&lt;class <span class="symbol">'dict</span>'&gt;</span><br><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="type">is </span>&lt;class <span class="symbol">'dict</span>'&gt;</span><br><span class="line">x <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;<span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="type">is </span>&lt;class <span class="symbol">'dict</span>'&gt;</span><br></pre></td></tr></table></figure></p><h3 id="args和-kwargs的混合使用"><a href="#args和-kwargs的混合使用" class="headerlink" title="*args和**kwargs的混合使用"></a>*args和**kwargs的混合使用</h3><p>*args和**kwargs在程序中一起使用很常见<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getTupleAndDict(x, *args, **kwargs):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'x is &#123;&#125;'</span>.<span class="built_in">format</span>(x))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'kwargs is &#123;&#125;'</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'args is &#123;&#125;'</span>.<span class="built_in">format</span>(args))</span><br><span class="line">getTupleAndDict(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, A=<span class="number">1</span>, B=<span class="number">2</span>, C=<span class="number">3</span>, D=<span class="number">4</span>)</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> <span class="keyword">is</span> <span class="number">1</span></span><br><span class="line">kwargs <span class="keyword">is</span> &#123;<span class="string">'D'</span>: <span class="number">4</span>, <span class="string">'C'</span>: <span class="number">3</span>, <span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'B'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="keyword">args</span> <span class="keyword">is</span> (<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;*args和**kwargs这两个参数咱们经常用到，今天在巩固基础的时候，看到了这两个参数，做了一下对比，所以记录一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;args&quot;&gt;&lt;a href=&quot;#args&quot; class=&quot;headerlink&quot; title=&quot;*args&quot;&gt;&lt;/a&gt;*args&lt;/h3&gt;&lt;p&gt;*args这种写法代表的是 &lt;strong&gt;元组&lt;/strong&gt;，就比如我上面为啥说它们是参数，是因为他们经常在函数的参数中出现。&lt;br&gt;下面咱们在例子中来说明&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux find命令的使用</title>
    <link href="http://yoursite.com/2018/12/29/Linux-find%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/12/29/Linux-find命令的使用/</id>
    <published>2018-12-29T07:58:44.000Z</published>
    <updated>2018-12-29T09:03:06.500Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。<br><a id="more"></a></p></blockquote><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>find 地址 参数 </p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</span><br><span class="line">expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</span><br><span class="line">-mount, -<span class="string">xdev :</span> 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</span><br><span class="line">-amin <span class="string">n :</span> 在过去 n 分钟内被读取过</span><br><span class="line">-anewer <span class="string">file :</span> 比文件 file 更晚被读取过的文件</span><br><span class="line">-atime <span class="string">n :</span> 在过去n天内被读取过的文件</span><br><span class="line">-cmin <span class="string">n :</span> 在过去 n 分钟内被修改过</span><br><span class="line">-cnewer <span class="string">file :</span>比文件 file 更新的文件</span><br><span class="line">-ctime <span class="string">n :</span> 在过去n天内被修改过的文件</span><br><span class="line">-<span class="string">empty :</span> 空的文件-gid n or -group <span class="string">name :</span> gid 是 n 或是 group 名称是 name</span><br><span class="line">-ipath p, -path <span class="string">p :</span> 路径名称符合 p 的文件，ipath 会忽略大小写</span><br><span class="line">-name name, -iname <span class="string">name :</span> 文件名称符合 name 的文件。iname 会忽略大小写</span><br><span class="line">-size <span class="string">n :</span> 文件大小 是 n 单位，b 代表 <span class="number">512</span> 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type <span class="string">c :</span> 文件类型是 c 的文件。</span><br><span class="line"><span class="string">d:</span> 目录</span><br><span class="line"><span class="string">c:</span> 字型装置文件</span><br><span class="line"><span class="string">b:</span> 区块装置文件</span><br><span class="line"><span class="string">p:</span> 具名贮列</span><br><span class="line"><span class="string">f:</span> 一般文件</span><br><span class="line"><span class="string">l:</span> 符号连结</span><br><span class="line"><span class="string">s:</span> socket</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>查找当前目录及其子目录下的名字为Podfile的文件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> . -name Podfile</span><br></pre></td></tr></table></figure></p><p>查找etc目录下名字为所有延伸档名是 .c 的文件列出来<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> /etc -<span class="built_in">name</span> <span class="string">'*.c'</span></span><br></pre></td></tr></table></figure></p><p>查找在系统中最后10分钟访问的文件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> / -amin -10</span><br></pre></td></tr></table></figure></p><p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">find</span> . -ctime -20</span><br></pre></td></tr></table></figure></p><p>查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> /<span class="built_in">var</span>/<span class="built_in">log</span> -<span class="built_in">type</span> f -mtime +<span class="number">7</span> -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">find</span> . -<span class="keyword">type</span> f -perm 644 -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> f -<span class="built_in">size</span> <span class="number">0</span> -<span class="built_in">exec</span> ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><p>其他的例子<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">find / -amin -<span class="number">10</span> 　　<span class="comment"># 查找在系统中最后10分钟访问的文件(access time)</span></span><br><span class="line">find / -atime -<span class="number">2</span>　　 <span class="comment"># 查找在系统中最后48小时访问的文件</span></span><br><span class="line">find / -empty 　　<span class="comment"># 查找在系统中为空的文件或者文件夹</span></span><br><span class="line">find / -<span class="keyword">group</span> <span class="title">cat</span> 　　<span class="comment"># 查找在系统中属于 group为cat的文件</span></span><br><span class="line">find / -mmin -<span class="number">5</span> 　　<span class="comment"># 查找在系统中最后5分钟里修改过的文件(modify time)</span></span><br><span class="line">find / -mtime -<span class="number">1</span> 　　<span class="comment">#查找在系统中最后24小时里修改过的文件</span></span><br><span class="line">find / -<span class="keyword">user</span> <span class="title">fred</span> 　　<span class="comment">#查找在系统中属于fred这个用户的文件</span></span><br><span class="line">find / -size +<span class="number">10000</span>c　　<span class="comment">#查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)</span></span><br><span class="line">find / -size -<span class="number">1000</span>k 　　<span class="comment">#查找出小于1000KB的文件</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.使用混合查找方式查找文件</span><br><span class="line"></span><br><span class="line">　参数有： ！，-<span class="keyword">and</span>(-a)，-<span class="keyword">or</span>(-o)。</span><br><span class="line">find /tmp -size +<span class="number">10000</span>c -<span class="keyword">and</span> -mtime +<span class="number">2</span> 　　<span class="comment">#在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</span></span><br><span class="line">find / -<span class="keyword">user</span> <span class="title">fred</span> -<span class="keyword">or</span> -<span class="keyword">user</span> <span class="title">george</span> 　　<span class="comment">#在/目录下查找用户是fred或者george的文件文件</span></span><br><span class="line">find /tmp ! -<span class="keyword">user</span> <span class="title">panda</span>　　<span class="comment">#在/tmp目录中查找所有不属于panda用户的文件</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>2019年读书计划</title>
    <link href="http://yoursite.com/2018/12/29/%E6%9D%82%E8%B0%88/"/>
    <id>http://yoursite.com/2018/12/29/杂谈/</id>
    <published>2018-12-29T07:58:18.000Z</published>
    <updated>2019-02-13T02:17:39.414Z</updated>
    
    <content type="html"><![CDATA[<p>2018年很快进入了尾声，想想今年不在想过碌碌无为的事情，开始有了自己的规划。一方面可能是因为有了压力，另一方面感觉自己需要更多的成长。2018年定的任务完成度完成了70%，自己感觉完成的不好。需要更多的激励，更多的鞭策。在最后的2018年的几天了，想着自己2019年的规划，落实到实际过程中，不在庸庸碌碌，用这边文章来写下自己的心路历程。只写自己的2019年所看的书籍</p><h3 id="拓展书籍"><a href="#拓展书籍" class="headerlink" title="拓展书籍"></a>拓展书籍</h3><p>读至少12本书，也就是一个月一本书 PS:以后再补充</p><ul><li>风闻有你</li><li>耶路撒冷三千年</li><li>加尔文要义(上)</li><li>加尔文要义(中)</li><li>加尔文要义(下)</li><li>穆斯林的葬礼</li></ul><h3 id="专业书籍"><a href="#专业书籍" class="headerlink" title="专业书籍"></a>专业书籍</h3><p>随着工作，发现自己需要学习的越来越多，所以今年至少需要看的书籍。PS:以后再补充</p><ul><li>跟着老齐学python(持之以恒，有始有终)</li><li>数据结构</li><li>python核心编程</li><li>算法</li></ul><h3 id="圣经"><a href="#圣经" class="headerlink" title="圣经"></a>圣经</h3><p>怎么都不能没有自己的信仰，圣经也是需要读一遍</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018年很快进入了尾声，想想今年不在想过碌碌无为的事情，开始有了自己的规划。一方面可能是因为有了压力，另一方面感觉自己需要更多的成长。2018年定的任务完成度完成了70%，自己感觉完成的不好。需要更多的激励，更多的鞭策。在最后的2018年的几天了，想着自己2019年的规划
      
    
    </summary>
    
      <category term="杂记" scheme="http://yoursite.com/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Supervisor管理进程</title>
    <link href="http://yoursite.com/2018/12/26/Supervisor%E7%AE%A1%E7%90%86%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/26/Supervisor管理进程/</id>
    <published>2018-12-26T07:27:04.000Z</published>
    <updated>2019-01-16T08:33:05.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 Supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，Supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip 安装:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip <span class="keyword">install</span> supervisor</span><br></pre></td></tr></table></figure></p><p>因为supervisor，只能安装在python2.X上面，目前开发用的是3.5.0，所以这里用到了pyenv。pyenv来管理用python2.X还是python3.X。学习pyenv请点链接：<a href="https://blog.gideondudu.com/2018/10/31/Mac%E4%B8%8Bpyenv%E4%B8%8Epyenv-virtualenv%E7%9A%84%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">pyenv</a></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><blockquote><p>Supervisor 相当强大，提供了很丰富的功能，不过我们可能只需要用到其中一小部分。安装完成之后，可以编写配置文件，来满足自己的需求。为了方便，我们把配置分成两部分 Supervisor（Supervisor 是一个 C/S 模型的程序，这是 server 端，对应的有 client 端：supervisorctl）和应用程序（即我们要管理的程序）</p></blockquote><p>首先来看 Supervisor 的配置文件。安装完 Supervisor 之后，可以运行 echo_supervisord_conf 命令输出默认的配置项，也可以重定向到一个配置文件里：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span>_supervisord_conf &gt; <span class="string">/etc/supervisord.conf</span></span><br></pre></td></tr></table></figure></p><p>去除里面大部分注释和“不相关”的部分，我们可以先看这些配置：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[unix_http_server]</span><br><span class="line">file=/tmp/supervisor.sock   ; UNIX socket 文件，supervisorctl 会使用</span><br><span class="line">;chmod=0700                 ; socket 文件的 mode，默认是 0700</span><br><span class="line"><span class="section">;chown=nobody:nogroup       ; socket 文件的 owner，格式： uid:gid</span></span><br><span class="line">;[inet_http_server]         ; HTTP 服务器，提供 web 管理界面</span><br><span class="line"><span class="section">;port=127.0.0.1:9001        ; Web 管理后台运行的 IP 和端口，如果开放到公网，需要注意安全性</span></span><br><span class="line">;username=user              ; 登录管理后台的用户名</span><br><span class="line">;password=123               ; 登录管理后台的密码</span><br><span class="line">[supervisord]</span><br><span class="line">logfile=/tmp/supervisord.log ; 日志文件，默认是 $CWD/supervisord.log</span><br><span class="line">logfile_maxbytes=50MB        ; 日志文件大小，超出会 rotate，默认 50MB</span><br><span class="line">logfile_backups=10           ; 日志文件保留备份数量默认 10</span><br><span class="line">loglevel=info                ; 日志级别，默认 info，其它: debug,warn,trace</span><br><span class="line">pidfile=/tmp/supervisord.pid ; pid 文件</span><br><span class="line">nodaemon=false               ; 是否在前台启动，默认是 false，即以 daemon 的方式启动</span><br><span class="line">minfds=1024                  ; 可以打开的文件描述符的最小值，默认 1024</span><br><span class="line">minprocs=200                 ; 可以打开的进程数的最小值，默认 200</span><br><span class="line">; the below section must remain in the config file for RPC</span><br><span class="line">; (supervisorctl/web interface) to work, additional interfaces may be</span><br><span class="line">; added by defining them in separate rpcinterface: sections</span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span></span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line">[supervisorctl]</span><br><span class="line">serverurl=unix:///tmp/supervisor.sock ; 通过 UNIX socket 连接 supervisord，路径与 unix_http_server 部分的 file 一致</span><br><span class="line"><span class="section">;serverurl=http://127.0.0.1:9001 ; 通过 HTTP 的方式连接 supervisord</span></span><br><span class="line">; 包含其他的配置文件</span><br><span class="line">[<span class="keyword">include</span>]</span><br><span class="line">files = relative/directory/*.ini    ; 可以是 *.conf 或 *.ini</span><br></pre></td></tr></table></figure></p><p>我们把上面这部分配置保存到 /etc/supervisord.conf（或其他任意有权限访问的文件）然后启动 supervisord（通过 -c 选项指定配置文件路径，如果不指定会按照这个顺序查找配置文件：$CWD/supervisord.conf, $CWD/etc/supervisord.conf, /etc/supervisord.conf）<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c <span class="regexp">/etc/</span>supervisord.conf</span><br></pre></td></tr></table></figure></p><p>查看 supervisord 是否在运行：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ps</span> aux | <span class="keyword">grep</span> supervisord</span><br></pre></td></tr></table></figure></p><h2 id="program-配置"><a href="#program-配置" class="headerlink" title="program 配置"></a>program 配置</h2><p>上面我们已经把 supervisrod 运行起来了，现在可以添加我们要管理的进程的配置文件。可以把所有配置项都写到 supervisord.conf 文件里，但并不推荐这样做，而是通过 include 的方式把不同的程序（组）写到不同的配置文件里。<br>为了举例，我们新建一个目录 /etc/supervisor/ 用于存放这些配置文件，相应的，把 /etc/supervisord.conf 里 include 部分的的配置修改一下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure></p><p>假设有个用 Python 和 Flask 框架编写的用户中心系统，取名 usercenter，用 gunicorn 做 web 服务器。项目代码位于 /home/leon/projects/usercenter，gunicorn 配置文件为 gunicorn.py，WSGI callable 是 wsgi.py 里的 app 属性。所以直接在命令行启动的，方式可能是这样的：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/home/</span>leon<span class="regexp">/projects/</span>usercenter</span><br><span class="line">gunicorn -c gunicorn.py <span class="string">wsgi:</span>app</span><br></pre></td></tr></table></figure></p><p>现在编写一份配置文件来管理这个进程（需要注意：用 supervisord 管理时，gunicorn 的 daemon 选项需要设置为 False）：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:usercenter]</span></span><br><span class="line"><span class="attr">directory</span> = /home/leon/projects/usercenter ; 程序的启动目录</span><br><span class="line"><span class="attr">command</span> = gunicorn -c gunicorn.py wsgi:app  ; 启动命令，可以看出与手动在命令行启动的命令是一样的</span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span>     ; 在 supervisord 启动的时候也自动启动</span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span>        ; 启动 <span class="number">5</span> 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span>   ; 程序异常退出后自动重启</span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span>     ; 启动失败自动重试次数，默认是 <span class="number">3</span></span><br><span class="line"><span class="attr">user</span> = leon          ; 用哪个用户启动</span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span>  ; 把 stderr 重定向到 stdout，默认 <span class="literal">false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">20</span>MB  ; stdout 日志文件大小，默认 <span class="number">50</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span>     ; stdout 日志文件备份数</span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /data/logs/usercenter_stdout.log</span><br><span class="line"><span class="comment">; 可以通过 environment 来添加需要的环境变量，一种常见的用法是修改 PYTHONPATH</span></span><br><span class="line"><span class="comment">; environment=PYTHONPATH=$PYTHONPATH:/path/to/somewhere</span></span><br></pre></td></tr></table></figure></p><p>一份配置文件至少需要一个 [program:x] 部分的配置，来告诉 supervisord 需要管理那个进程。[program:x] 语法中的 x 表示 program name，会在客户端（supervisorctl 或 web 界面）显示，在 supervisorctl 中通过这个值来对程序进行 start、restart、stop 等操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Supervisor 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Supervisor" scheme="http://yoursite.com/tags/Supervisor/"/>
    
  </entry>
  
  <entry>
    <title>python数组的相关知识</title>
    <link href="http://yoursite.com/2018/12/25/python%E6%95%B0%E7%BB%84%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/12/25/python数组交集、并集、差集/</id>
    <published>2018-12-25T02:43:28.000Z</published>
    <updated>2018-12-25T03:05:26.679Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数组是在python中很常见，所以关于数组的知识点也相当重要。这篇博客是把工作中用到的知识点记录一下，持续更新中</p></blockquote><a id="more"></a><p>1、<a href="#markdown-jiaoji">数组的交集、并集、差集</a><br>2、<a href="#markdown-zhuanhuan">数组转字符串，字符串转数组</a></p><h2 id="数组的交集、并集、差集"><a href="#数组的交集、并集、差集" class="headerlink" title="数组的交集、并集、差集"></a><a name="markdown-jiaoji"></a>数组的交集、并集、差集</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 3, 65, 2, 7]</span><br><span class="line">b = [3, 2, 5, 4]</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(a).intersection(<span class="builtin-name">set</span>(b))) # 交集</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(a).union(<span class="builtin-name">set</span>(b))) # 并集</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(a).difference(<span class="builtin-name">set</span>(b))) # 差集，在a中但不在b中的元素</span><br><span class="line"><span class="builtin-name">print</span>(<span class="builtin-name">set</span>(b).difference(<span class="builtin-name">set</span>(a))) # 差集，在b中但不在a中的元素</span><br></pre></td></tr></table></figure><p>结果<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">&#123;<span class="number">65</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">65</span>, <span class="number">1</span>, <span class="number">7</span>&#125;</span><br><span class="line">&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数组转字符串，字符串转数组"><a href="#数组转字符串，字符串转数组" class="headerlink" title="数组转字符串，字符串转数组"></a><a name="markdown-zhuanhuan"></a>数组转字符串，字符串转数组</h2><p><strong>字符串转数组</strong><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">'1,2,3'</span></span><br><span class="line">arr = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">','</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"arr is &#123;&#125;"</span>.format(arr))</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr <span class="keyword">is</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure></p><p><strong>数组转字符串</strong><br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1</span></span><br><span class="line">arr = [<span class="string">'a'</span>,<span class="string">'b'</span>]</span><br><span class="line">str1 = <span class="string">','</span>.<span class="keyword">join</span>(arr)</span><br><span class="line">print(<span class="string">'str1 is &#123;&#125;'</span>.<span class="keyword">format</span>(str1))</span><br><span class="line"><span class="comment">#方法2</span></span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">str2 = <span class="string">','</span>.<span class="keyword">join</span>(str(i) <span class="keyword">for</span> i in arr)</span><br><span class="line">print(<span class="string">'str2 is &#123;&#125;'</span>.<span class="keyword">format</span>(str2))</span><br></pre></td></tr></table></figure></p><p>结果<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 is <span class="selector-tag">a</span>,b</span><br><span class="line">str2 is <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;数组是在python中很常见，所以关于数组的知识点也相当重要。这篇博客是把工作中用到的知识点记录一下，持续更新中&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Flask-OAuth urlparse错误</title>
    <link href="http://yoursite.com/2018/12/13/Flask-OAuth-urlparse%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/12/13/Flask-OAuth-urlparse错误/</id>
    <published>2018-12-13T07:52:27.000Z</published>
    <updated>2018-12-13T07:58:38.402Z</updated>
    
    <content type="html"><![CDATA[<p>最近用到了Flash-OAuth的三方库，一运行，错误<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">File</span> <span class="string">"/Users/FQY/Desktop/bm_blog/blog/extensions.py"</span>, <span class="built_in">line</span> <span class="number">10</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    from flask_oauth <span class="keyword">import</span> OAuth</span><br><span class="line">  <span class="built_in">File</span> <span class="string">"/Users/FQY/env350/lib/python3.5/site-packages/flask_oauth.py"</span>, <span class="built_in">line</span> <span class="number">13</span>, in &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    from urlparse <span class="keyword">import</span> parse</span><br><span class="line">ImportError: No <span class="keyword">module</span> named <span class="string">'urlparse'</span></span><br></pre></td></tr></table></figure></p><p>先说明下我用的python环境是<code>3.5.0</code>,百度下说是<code>from urlparse import urljoin</code> 是2.0的python用法，3.0的python用法已经urlparse已经被重新设置,所以进入三方库里面改下就可以了。<br>进入flask_oauth.py文件中进行修改<br><strong>原代码</strong><br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httplib2</span><br><span class="line"><span class="title">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="title">from</span> urlparse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="title">from</span> flask <span class="keyword">import</span> request, session, json, redirect, Response</span><br><span class="line"><span class="title">from</span> werkzeug <span class="keyword">import</span> url_decode, url_encode, url_quote, \</span><br><span class="line">     parse_options_header, <span class="type">Headers</span></span><br><span class="line"><span class="keyword">import</span> oauth2</span><br></pre></td></tr></table></figure></p><p><strong>修改以后的代码</strong><br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> httplib2</span><br><span class="line"><span class="title">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="title">from</span> urllib.parse <span class="keyword">import</span> urljoin</span><br><span class="line"><span class="title">from</span> flask <span class="keyword">import</span> request, session, json, redirect, Response</span><br><span class="line"><span class="title">from</span> werkzeug <span class="keyword">import</span> url_decode, url_encode, url_quote, \</span><br><span class="line">     parse_options_header, <span class="type">Headers</span></span><br><span class="line"><span class="keyword">import</span> oauth2</span><br></pre></td></tr></table></figure></p><p>这时候在运行就可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用到了Flash-OAuth的三方库，一运行，错误&lt;br&gt;&lt;figure class=&quot;highlight arduino&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux tree:目录结构以树形显示</title>
    <link href="http://yoursite.com/2018/12/12/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%BB%A5%E6%A0%91%E5%BD%A2%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2018/12/12/目录结构以树形显示/</id>
    <published>2018-12-12T06:51:20.000Z</published>
    <updated>2018-12-12T06:58:07.918Z</updated>
    
    <content type="html"><![CDATA[<p>有时候看到别人的目录结构是以树形显示，看到以后感觉很酷，所以自己就google了下，发现了很简单。</p><p><strong>实例</strong><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY@bogon ~/Desktop/hello</span><br><span class="line">╰─$ tree </span><br><span class="line">.</span><br><span class="line">├── dong.txt</span><br><span class="line">├── dong_s<span class="selector-class">.txt</span> -&gt; dong.txt</span><br><span class="line">├── hell</span><br><span class="line">│   ├── hell</span><br><span class="line">│   │   └── hello</span><br><span class="line">│   └── hello</span><br><span class="line">├── hello</span><br><span class="line">├── hello1</span><br><span class="line">├── hello_s -&gt; hello</span><br><span class="line">└── tmd.rtf</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> directories, <span class="number">8</span> files</span><br></pre></td></tr></table></figure></p><p>具体更多的关于tree的指令，后期在补充</p><p>未完接续。。。。。。。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时候看到别人的目录结构是以树形显示，看到以后感觉很酷，所以自己就google了下，发现了很简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gu
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux file命令:查看文件信息或类型</title>
    <link href="http://yoursite.com/2018/12/11/Linux-file%E5%91%BD%E4%BB%A4-%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E6%88%96%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/12/11/Linux-file命令-查看文件信息或类型/</id>
    <published>2018-12-11T08:32:25.000Z</published>
    <updated>2018-12-11T09:28:32.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux file命令用于辨识文件类型,通过file指令，我们得以辨识该文件的类型。</p></blockquote><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]<br><strong>参数</strong></p><ul><li>-b 　列出辨识结果时，不显示文件名称。</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。</li><li>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。</li><li>-L 　直接显示符号连接所指向的文件的类别。</li><li>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。</li><li>-v 　显示版本信息。</li><li>-z 　尝试去解读压缩文件的内容 (支持gzip类型)。</li><li>[文件或目录…]要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件</li></ul></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h5 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[root@hardwareupdate linux_test]</span># <span class="selector-tag">file</span> <span class="selector-tag">hello</span><span class="selector-class">.txt</span></span><br><span class="line"><span class="selector-tag">hello</span><span class="selector-class">.txt</span>: <span class="selector-tag">UTF-8</span> <span class="selector-tag">Unicode</span> <span class="selector-tag">text</span></span><br></pre></td></tr></table></figure><p>使用不带任何选项的 file 命令，即可查看指定文件的类型信息。在上面的例子中可以看出 poetry.txt 的文件类型为 text，编码格式为 UTF-8。</p><p>使用<code>-b</code>就只显示编码和文件类型，不显示文件名<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hardwareupdate linux_test]# <span class="keyword">file</span> -b hello.txt</span><br><span class="line">UTF<span class="number">-8</span> Unicode <span class="keyword">text</span></span><br></pre></td></tr></table></figure></p><p>使用<code>-i</code>，咱们能看出什么?<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@hardwareupdate linux_test]# <span class="keyword">file</span> -i hello.txt</span><br><span class="line">hello.txt: <span class="keyword">text</span>/plain; charset=utf<span class="number">-8</span></span><br></pre></td></tr></table></figure></p><p><strong>常见的文件类型：</strong></p><ul><li>text/plain：普通文本。</li><li>text/html：HTML文本。</li><li>application/pdf：PDF文档。</li><li>application/msword：Word文档。</li><li>image/png：PNG图片。</li><li>mage/jpeg：JPEG图片。</li><li>application/x-tar：TAR文件。</li><li>application/x-gzip：GZIP文件</li></ul><h5 id="按照清单去工作"><a href="#按照清单去工作" class="headerlink" title="按照清单去工作"></a>按照清单去工作</h5><p>如果我们需要用 file 命令查看大量文件的类型信息，恰好这些文件的名称都被存储在了一个文本文件中，那么-f选项就派上用场了。我们可以通过-f选项来指定这个文本文件，file 命令就会乖乖地去逐个查看每一个文件的类型信息，示例如下:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#文件中含有三个待查文件, 我们故意设置了一个不存在的文件, 位于最后一个</span></span><br><span class="line">[roc@roclinux ~]$ cat poetry_list.txt</span><br><span class="line">/root/book/poetry.txt</span><br><span class="line">/root/book/poetry_s.txt</span><br><span class="line"><span class="literal">Nothing</span>.txt</span><br><span class="line"> </span><br><span class="line"><span class="meta">#使用-f选项执行file命令</span></span><br><span class="line">[roc@roclinux ~]$ file -f poetry_list.txt</span><br><span class="line">/root/book/poetry.txt:   ASCII <span class="keyword">text</span></span><br><span class="line">/root/book/poetry_s.txt: symbolic link <span class="keyword">to</span> `poetry.txt<span class="comment">'</span></span><br><span class="line"><span class="literal">Nothing</span>.txt: <span class="keyword">ERROR</span>: cannot open `<span class="literal">Nothing</span>.txt <span class="comment">' (No such file or directory)</span></span><br></pre></td></tr></table></figure></p><p>其他的各种指令，大家也可以去尝试，比如<code>-L</code>，当用软链接的时候不会直接返回文件类型，而是返回的是<code>symbolic link to XXX</code>，所以加<code>-L</code>就可以知道它是哪个类型了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://c.biancheng.net/linux/file.html" target="_blank" rel="noopener">file命令_Linux file命令：查看文件信息或类型</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux file命令用于辨识文件类型,通过file指令，我们得以辨识该文件的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的HTTP状态码(HTTP Status Code)</title>
    <link href="http://yoursite.com/2018/12/11/%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81-HTTP-Status-Code/"/>
    <id>http://yoursite.com/2018/12/11/常见的HTTP状态码-HTTP-Status-Code/</id>
    <published>2018-12-11T03:29:43.000Z</published>
    <updated>2018-12-11T03:37:29.901Z</updated>
    
    <content type="html"><![CDATA[<p>2开头 （请求成功）表示成功处理了请求的状态代码。<br>200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。<br>201   （已创建）  请求成功并且服务器创建了新的资源。<br>202   （已接受）  服务器已接受请求，但尚未处理。<br>203   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。<br>204   （无内容）  服务器成功处理了请求，但没有返回任何内容。<br>205   （重置内容） 服务器成功处理了请求，但没有返回任何内容。<br>206   （部分内容）  服务器成功处理了部分 GET 请求,流视频直播一般返回206</p><p>3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</p><p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。<br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。<br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。<br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。<br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。<br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。<br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。<br>400   （错误请求） 服务器不理解请求的语法。<br>401   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403   （禁止） 服务器拒绝请求。<br>404   （未找到） 服务器找不到请求的网页。<br>405   （方法禁用） 禁用请求中指定的方法。<br>406   （不接受） 无法使用请求的内容特性响应请求的网页。<br>407   （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。<br>408   （请求超时）  服务器等候请求时发生超时。<br>409   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。<br>410   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。<br>411   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。<br>412   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。<br>414   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。<br>415   （不支持的媒体类型） 请求的格式不受请求页面的支持。<br>416   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。<br>417   （未满足期望值） 服务器未满足”期望”请求标头字段的要求。</p><p>5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。</p><p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。<br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。<br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。<br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。<br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。<br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2开头 （请求成功）表示成功处理了请求的状态代码。&lt;br&gt;200   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。&lt;br&gt;201   （已创建）  请求成功并且服务器创建了新的资源。&lt;br&gt;202   （已接受）  服务器已接受请求，但尚未处理
      
    
    </summary>
    
      <category term="http" scheme="http://yoursite.com/categories/http/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux文件管理之cmp、diff的使用详解</title>
    <link href="http://yoursite.com/2018/12/10/Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E4%B9%8Bcmp%E3%80%81diff%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/10/Linux文件管理之cmp、diff的使用详解/</id>
    <published>2018-12-10T03:41:40.000Z</published>
    <updated>2018-12-10T06:02:46.635Z</updated>
    
    <content type="html"><![CDATA[<p>cmp和diff都是用于比较两个文件的差异。但是两者的不同之处在于:</p><blockquote><p>cmp用于比较两个二进制文件，而diff主要用于比较两个文本文件<br><a id="more"></a></p></blockquote><h1 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h1><p>Linux cmp命令用于比较两个文件是否有差异。<br>当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>cmp [参数][文件1][文件2]</p></blockquote><p><strong>参数</strong></p><ul><li>-c或–print-chars 　除了标明差异处的十进制字码之外，一并显示该字符所对应字符。</li><li>-i&lt;字符数目&gt;或–ignore-initial=&lt;字符数目&gt; 　指定一个数目。</li><li>-l或–verbose 　标示出所有不一样的地方。</li><li>-s或–quiet或–silent 　不显示错误信息。</li><li>-v或–version 　显示版本信息。</li><li>–help 　在线帮助。<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp hello hello1   <span class="comment"># hello1是从hello复制的，然后在hello1添加了一些内容</span></span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp hello hello1   <span class="comment"># 出现EOF 是则 hello1 的第一部分与 hello 相同，但在 hello1 中还有其他数据</span></span><br><span class="line"><span class="symbol">cmp:</span> EOF on hello</span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp -l hello hello1 <span class="comment"># 这时候在hello中添加一些数据，在重新比较</span></span><br><span class="line"><span class="number">37</span> <span class="number">351</span> <span class="number">141</span></span><br><span class="line"><span class="number">38</span> <span class="number">230</span> <span class="number">163</span></span><br><span class="line"><span class="number">39</span> <span class="number">277</span> <span class="number">144</span></span><br><span class="line"><span class="number">40</span> <span class="number">346</span> <span class="number">146</span></span><br><span class="line"><span class="number">41</span> <span class="number">226</span> <span class="number">141</span></span><br><span class="line"><span class="symbol">cmp:</span> EOF on hello   </span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cmp  hello hello1                                                       <span class="number">1</span> ↵</span><br><span class="line">hello hello1 <span class="symbol">differ:</span> char <span class="number">37</span>, line <span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h1><p>Linux diff命令用于比较文件的差异。<br>diff以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则diff会比较目录中相同文件名的文件，但不会比较其中子目录</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><blockquote><p>diff[参数][文件1或目录1][文件2或目录2]</p></blockquote><p><strong>参数</strong></p><ul><li>-B或–ignore-blank-lines 　不检查空白行。</li><li>-c 　显示全部内文，并标出不同之处。</li><li>-C&lt;行数&gt;或–context&lt;行数&gt; 　与执行”-c-&lt;行数&gt;”指令相同。</li><li>-d或–minimal 　使用不同的演算法，以较小的单位来做比较。</li><li>-D&lt;巨集名称&gt;或ifdef&lt;巨集名称&gt; 　此参数的输出格式可用于前置处理器巨集。</li><li>-e或–ed 　此参数的输出格式可用于ed的script文件。</li><li>-f或-forward-ed 　输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</li><li>-H或–speed-large-files 　比较大文件时，可加快速度。</li><li>-l&lt;字符或字符串&gt;或–ignore-matching-lines&lt;字符或字符串&gt; 　若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</li><li>-i或–ignore-case 　不检查大小写的不同。</li><li>-l或–paginate 　将结果交由pr程序来分页。</li><li>-n或–rcs 　将比较结果以RCS的格式来显示。</li><li>-N或–new-file 　在比较目录时，若文件A仅出现在某个目录中，预设会显示：</li><li>Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</li><li>-p 　若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</li><li>-P或–unidirectional-new-file 　与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</li><li>-q或–brief 　仅显示有无差异，不显示详细的信息。</li><li>-r或–recursive 　比较子目录中的文件。</li><li>-s或–report-identical-files 　若没有发现任何差异，仍然显示信息。</li><li>-S&lt;文件&gt;或–starting-file&lt;文件&gt; 　在比较目录时，从指定的文件开始比较。</li><li>-t或–expand-tabs 　在输出时，将tab字符展开。</li><li>-T或–initial-tab 　在每行前面加上tab字符以便对齐。</li><li>-u,-U&lt;列数&gt;或–unified=&lt;列数&gt; 　以合并的方式来显示文件内容的不同。</li><li>-v或–version 　显示版本信息。</li><li>-w或–ignore-all-space 　忽略全部的空格字符。</li><li>-W&lt;宽度&gt;或–width&lt;宽度&gt; 　在使用-y参数时，指定栏宽。</li><li>-x&lt;文件名或目录&gt;或–exclude&lt;文件名或目录&gt; 　不比较选项中所指定的文件或目录。</li><li>-X&lt;文件&gt;或–exclude-from&lt;文件&gt; 　您可以将文件或目录类型存成文本文件，然后在=&lt;文件&gt;中指定此文本文件。</li><li>-y或–side-by-side 　以并列的方式显示文件的异同之处。</li><li>–help 　显示帮助。</li><li>–left-column 　在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</li><li>–suppress-common-lines 　在使用-y参数时，仅显示不同之处。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">╭─FQY@bogon</span> <span class="string">~/Desktop/hello</span></span><br><span class="line"><span class="string">╰─$</span> <span class="string">diff</span> <span class="string">hello</span> <span class="string">hello1</span>                                                       <span class="number">1</span> <span class="string">↵</span></span><br><span class="line"><span class="number">4</span><span class="string">c4,5</span></span><br><span class="line"><span class="string">&lt;</span> <span class="string">python好用</span></span><br><span class="line"><span class="string">\</span> <span class="literal">No</span> <span class="string">newline</span> <span class="string">at</span> <span class="string">end</span> <span class="string">of</span> <span class="string">file</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">&gt; node很方便</span></span><br><span class="line"><span class="string">&gt; 加油</span></span><br><span class="line"><span class="string">\ No newline at end of file </span></span><br><span class="line"><span class="string">╭─FQY@bogon ~/Desktop/hello</span></span><br><span class="line"><span class="string">╰─$ diff hello hello1 -y -W 50                                              2 ↵</span></span><br><span class="line"><span class="string">生活很美好       生活很美好</span></span><br><span class="line"><span class="string">现实很骨感       现实很骨感</span></span><br><span class="line"><span class="string">理想很丰富       理想很丰富</span></span><br><span class="line"><span class="string">python好用          \ node很方便</span></span><br><span class="line"><span class="string">              &gt; 加油%</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong><br>“|”表示前后2个文件内容有不同<br>“&lt;”表示后面文件比前面文件少了1行内容<br>“&gt;”表示后面文件比前面文件多了1行内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cmp和diff都是用于比较两个文件的差异。但是两者的不同之处在于:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;cmp用于比较两个二进制文件，而diff主要用于比较两个文本文件&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux cksum的使用详解</title>
    <link href="http://yoursite.com/2018/12/10/Linux-cksum%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/12/10/Linux-cksum的使用详解/</id>
    <published>2018-12-10T02:38:22.000Z</published>
    <updated>2018-12-10T02:55:23.341Z</updated>
    
    <content type="html"><![CDATA[<p>cksum命令是检查文件的CRC是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。这种方法要求校验和在源系统中被计算出来，在目的系统中又被计算一次，两个数字进行比较，如果校验和相等，则该文件被认为是正确传输了。<br>注意：CRC是指一种排错检查方法，即循环冗余校验法。<br>指定文件交由cksum命令进行校验后，会返回校验结果供用户核对文件是否正确无误。若不指定任何文件名称或是所给予的文件名为”-“，则cksum命令会从标准输入设备中读取数据。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>cksum [–help][–version][文件…]</p></blockquote><p><strong>参数</strong></p><ul><li>–help：在线帮助。</li><li>–version：显示版本信息。</li><li>文件…:需要进行检查的文件路径</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cksum hello  <span class="comment"># 命令执行后，将输出校验码等相关的信息</span></span><br><span class="line"><span class="number">4294967295</span> <span class="number">0</span> hello</span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>vim hello    <span class="comment"># 因为hello文件是空的，所以字节数为0，这时候给hello里面添加数据并保存</span></span><br><span class="line">╭─FQY<span class="variable">@bogon</span> ~<span class="regexp">/Desktop/hello</span></span><br><span class="line">╰─<span class="variable">$ </span>cksum hello  <span class="comment"># 再一次执行命令，这时候看到字节数是36。"4090568956"表示校验码</span></span><br><span class="line"><span class="number">4090568956</span> <span class="number">36</span> hello</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果文件中有任何字符被修改，都将改变计算后CRC校验码的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cksum命令是检查文件的CRC是否正确，确保文件从一个系统传输到另一个系统的过程中不被损坏。这种方法要求校验和在源系统中被计算出来，在目的系统中又被计算一次，两个数字进行比较，如果校验和相等，则该文件被认为是正确传输了。&lt;br&gt;注意：CRC是指一种排错检查方法，即循环冗余
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
</feed>
